(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{421:function(a,e,t){"use strict";t.r(e);var v=t(42),s=Object(v.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"java集合体系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java集合体系"}},[a._v("#")]),a._v(" Java集合体系")]),a._v(" "),t("hr"),a._v(" "),t("h2",{attrs:{id:"list接口实现类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list接口实现类"}},[a._v("#")]),a._v(" List接口实现类")]),a._v(" "),t("h3",{attrs:{id:"arraylist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[a._v("#")]),a._v(" ArrayList")]),a._v(" "),t("p",[a._v("JDK1.2加入，list接口的主要实现类。线程非安全，效率高。底层是Object[]实现。\n"),t("br")]),a._v(" "),t("p",[t("strong",[a._v("JDK7源码分析：")])]),a._v(" "),t("ul",[t("li",[a._v("ArrayList list = new ArrayList(); //此句默认调用午餐构造器，默认生成容量为10的object[]")]),a._v(" "),t("li",[a._v("add()方法，默认扩容是1.5倍（old+old>>2）")]),a._v(" "),t("li",[a._v("contains()方法调用元素类的equals()方法，时间复杂度是o(n)\n"),t("br")])]),a._v(" "),t("p",[t("strong",[a._v("JDK8源码分析：")])]),a._v(" "),t("ul",[t("li",[a._v("ArrayList list = new ArrayList(); //此句默认调用午餐构造器，默认生成空数组{}")]),a._v(" "),t("li",[a._v("add()方法，第一次添加一个元素，生成一个10容量的object[],默认扩容是1.5倍（old+old>>2）")]),a._v(" "),t("li",[a._v("contains()方法调用元素类的equals()方法，时间复杂度是o(n)\n"),t("br")])]),a._v(" "),t("p",[t("strong",[a._v("小结")]),a._v("jdk1.7之前是饿汉式创建，1.8之后属于延迟创建，提高内存的时间使用效率，防止默认10空间\n的数组在时间上浪费等待。")]),a._v(" "),t("h3",{attrs:{id:"linkedlist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[a._v("#")]),a._v(" LinkedList")]),a._v(" "),t("p",[a._v("jdk1.2加入。线程非安全，效率高。底层是双向链表。\n"),t("br")]),a._v(" "),t("p",[t("strong",[a._v("源码分析：")])]),a._v(" "),t("ul",[t("li",[a._v("无需扩容")]),a._v(" "),t("li",[a._v("最小元素Node(prev,element,next),当前容器类，能直接访问第一个和最后一个node.")]),a._v(" "),t("li",[a._v("contains()方法时间复杂度为o(n)")])]),a._v(" "),t("h3",{attrs:{id:"vector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vector"}},[a._v("#")]),a._v(" Vector")]),a._v(" "),t("p",[a._v("jdk1.1就存在。线程安全类，底层是Objecct[]\n"),t("br"),a._v(" "),t("strong",[a._v("源码分析：")])]),a._v(" "),t("ul",[t("li",[a._v("默认扩容是2倍")]),a._v(" "),t("li",[a._v("无参构造器为10容量")])]),a._v(" "),t("h2",{attrs:{id:"set接口实现类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set接口实现类"}},[a._v("#")]),a._v(" Set接口实现类")]),a._v(" "),t("p",[a._v("特点"),t("br")]),a._v(" "),t("ul",[t("li",[a._v("无序性：不等同与随机性。存储的数据在顶层数组中并非按照数组索引的顺序添加。而是根据数据的hash决定的。")]),a._v(" "),t("li",[a._v("不可重复性：保证的添加的按照equals()判断相同。")]),a._v(" "),t("li",[a._v("对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法,以实现对象相等规则。\n即“相等的对象必须具有相等的散列码”")])]),a._v(" "),t("h3",{attrs:{id:"treeset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treeset"}},[a._v("#")]),a._v(" TreeSet")]),a._v(" "),t("p",[a._v("信息：二叉树之红黑树。按照添加对象的指定属性排序(需要实现compare方法)"),t("br")]),a._v(" "),t("ul",[t("li",[a._v("TreeSet中的对象必须同一个类，因为需要用到同类对象的compare方法")]),a._v(" "),t("li",[a._v("自然排序：实现Comparable接口重写compareTo(Object obj),比较两个对象相同的标准变为\ncompareTo()返回0，而不是equals()")]),a._v(" "),t("li",[a._v("定制排序：new TreeSet(new Comparator{.....}),实现Comparator类作为构造器参数传入。\n比较两个对象的相同的标准变为campare()返回0.不再是equals()")])]),a._v(" "),t("h3",{attrs:{id:"hashset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[a._v("#")]),a._v(" HashSet")]),a._v(" "),t("p",[a._v("信息：Set接口的主要实现类，线程不安全，可以存储null"),t("br")]),a._v(" "),t("ul",[t("li",[a._v("不保证元素的排列顺序")]),a._v(" "),t("li",[a._v("HashSet非线程安全")]),a._v(" "),t("li",[a._v("集合元素可以是null")]),a._v(" "),t("li",[a._v("hashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回也相等")])]),a._v(" "),t("h3",{attrs:{id:"linkedhashset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashset"}},[a._v("#")]),a._v(" LinkedHashSet")]),a._v(" "),t("p",[a._v("信息：作为HashSet的子类。遍历内部数据，按照添加的顺序。"),t("br")]),a._v(" "),t("ul",[t("li",[a._v("添加数据的同时，每个数据还维护了两个引用，记录此数据的前一个数据和后一个数据")]),a._v(" "),t("li",[a._v("对于频繁的遍历的操作，LinkedHashSet效率更")])]),a._v(" "),t("h2",{attrs:{id:"map实现类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map实现类"}},[a._v("#")]),a._v(" Map实现类")]),a._v(" "),t("p",[a._v("特点")]),a._v(" "),t("ul",[t("li",[a._v("双列数据，存储key-value对的数据（函数映射）")]),a._v(" "),t("li",[a._v("key存储结构是Set,无序，不可重复  "),t("br"),a._v("\n---\x3e作为key的类需要重写hashCode()和equals()(针对HashMap)"),t("br"),a._v("\n---\x3e重写compareTo/compare(针对TreeMap)"),t("br")]),a._v(" "),t("li",[a._v("value存储结构是Collection,无序，可重复"),t("br"),a._v("\n---\x3e作为value的类需要重写equals()")]),a._v(" "),t("li",[a._v("一对key-value键值对构成一个Entry对象")]),a._v(" "),t("li",[a._v("Entry存储结构是Set,无序，不可重复")])]),a._v(" "),t("h3",{attrs:{id:"hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),t("p",[a._v("特点：Map的主要实现类（JDK1.2加入），线程非安全，效率高，允许null值key和null值value"),t("br"),a._v("\njdk1.7之前是数组+链表，1.8之后是数组+链表+红黑树"),t("br")]),a._v(" "),t("p",[t("strong",[a._v("JDK7源码解析：")]),a._v("\nHashMap map = new HashMap():"),t("br"),a._v("\n在实例化以后，底层创建了长度是16的一维数组Entry[] table。"),t("br"),a._v("\n...可能已经执行过多次put..."),t("br"),a._v("\nmap.put(key1,value1):"),t("br")]),a._v(" "),t("p",[a._v("首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("如果此位置上的数据为空，此时的key1-value1添加成功。 "),t("strong",[a._v("----情况1")]),t("br"),a._v("\n如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：")])]),a._v(" "),t("li",[t("p",[a._v("如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。"),t("strong",[a._v("----情况2")]),t("br"),a._v("\n如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：")])]),a._v(" "),t("li",[t("p",[a._v("如果equals()返回false:此时key1-value1添加成功。"),t("strong",[a._v("----情况3")]),t("br"),a._v("\n如果equals()返回true:使用value1替换value2。")])])]),a._v(" "),t("p",[t("strong",[a._v("补充")]),a._v("：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。\n在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。\n默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。")]),a._v(" "),t("p",[t("strong",[a._v("JDK8源码解析：")])]),a._v(" "),t("ul",[t("li",[a._v("new HashMap():底层没有创建一个长度为16的数组")]),a._v(" "),t("li",[a._v("jdk 8底层的数组是：Node[],而非Entry[]")]),a._v(" "),t("li",[a._v("首次调用put()方法时，底层创建长度为16的数组")]),a._v(" "),t("li",[a._v("jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。"),t("br"),a._v("\n---\x3e形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）"),t("br"),a._v("\n---\x3e当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64时，此时此索引位置上的所数据改为使用红黑树存储。")])]),a._v(" "),t("p",[t("strong",[a._v("DEFAULT_INITIAL_CAPACITY")]),a._v(" : HashMap的默认容量，16"),t("br"),a._v(" "),t("strong",[a._v("DEFAULT_LOAD_FACTOR")]),a._v("：HashMap的默认加载因子：0.75"),t("br"),a._v(" "),t("strong",[a._v("threshold")]),a._v("：扩容的临界值，=容量*填充因子：16 * 0.75 => 12"),t("br"),a._v(" "),t("strong",[a._v("TREEIFY_THRESHOLD")]),a._v("：Bucket中链表长度大于该默认值，转化为红黑树:8"),t("br"),a._v(" "),t("strong",[a._v("MIN_TREEIFY_CAPACITY")]),a._v("：桶中的Node被树化时最小的hash表容量:64"),t("br")]),a._v(" "),t("h3",{attrs:{id:"linkedhashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap"}},[a._v("#")]),a._v(" LinkedHashMap")]),a._v(" "),t("p",[t("strong",[a._v("特点")]),a._v("：保证在遍历map元素时，可以按照添加的顺序实现遍历。在原有的HashMap底层结构上添加了一队指针，指向前一个和后一个元素。\n对于频繁遍历的操作，LinkedHashMap效率更高。"),t("br"),a._v(" "),t("strong",[a._v("源码解析：")]),t("br")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("static class Entry<K,V> extends HashMap.Node<K,V> {\n     Entry<K,V> before, after;//能够记录添加的元素的先后顺序\n     Entry(int hash, K key, V value, Node<K,V> next) {\n          super(hash, key, value, next);\n     }\n}\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("h3",{attrs:{id:"treemap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[a._v("#")]),a._v(" TreeMap")]),a._v(" "),t("p",[t("strong",[a._v("特点")]),a._v("：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序和定制排序"),t("br"),a._v("\n底层是红黑树")]),a._v(" "),t("h3",{attrs:{id:"hashtable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[a._v("#")]),a._v(" Hashtable")]),a._v(" "),t("p",[t("strong",[a._v("特点")]),a._v("：古老类（JDK1.0加入），线程安全，效率低，不允许null值key和null值value")]),a._v(" "),t("h3",{attrs:{id:"properties"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#properties"}},[a._v("#")]),a._v(" Properties")]),a._v(" "),t("p",[t("strong",[a._v("特点")]),a._v("：常用来处理配置文件，key和value都是string类型")])])}),[],!1,null,null,null);e.default=s.exports}}]);