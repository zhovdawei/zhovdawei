(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{418:function(a,s,n){"use strict";n.r(s);var e=n(42),t=Object(e.a)({},(function(){var a=this,s=a.$createElement,n=a._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"java线程体系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java线程体系"}},[a._v("#")]),a._v(" Java线程体系")]),a._v(" "),n("hr"),a._v(" "),n("h2",{attrs:{id:"java内存模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型"}},[a._v("#")]),a._v(" Java内存模型")]),a._v(" "),n("h3",{attrs:{id:"内存间交互操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存间交互操作"}},[a._v("#")]),a._v(" 内存间交互操作")]),a._v(" "),n("ul",[n("li",[a._v("lock(锁定): 作用于主内存的变量，它把一个变量标识为一条线程独占的状态。")]),a._v(" "),n("li",[a._v("unlock(解锁): 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。")]),a._v(" "),n("li",[a._v("read(读取): 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用")]),a._v(" "),n("li",[a._v("load(载入): 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存的变量副本中")]),a._v(" "),n("li",[a._v("use(使用): 作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到的一个需要使用\n变量的值的字节码指令时将会执行这个操作")]),a._v(" "),n("li",[a._v("assign(赋值): 作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值\n的字节码指令时执行这个操作")]),a._v(" "),n("li",[a._v("store(存储): 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用")]),a._v(" "),n("li",[a._v("write(写入): 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。")])]),a._v(" "),n("hr"),a._v(" "),n("h2",{attrs:{id:"线程状态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程状态"}},[a._v("#")]),a._v(" 线程状态")]),a._v(" "),n("p",[n("img",{attrs:{src:"/images/interview/iw-1.png",alt:""}}),n("br"),a._v(" "),n("img",{attrs:{src:"/images/interview/iw-2.png",alt:""}}),n("br")]),a._v(" "),n("ul",[n("li",[n("strong",[a._v("NEW")]),a._v("：构造了thread实例，但是还没有start")]),a._v(" "),n("li",[n("strong",[a._v("RUNNABLE")]),a._v("：线程正在运行或者正等待被cpu执行")]),a._v(" "),n("li",[n("strong",[a._v("BLOCKED")]),a._v("：线程调用synchronized关键字等待获取monitor锁")]),a._v(" "),n("li",[n("strong",[a._v("WAITING")]),a._v("：线程调用了无超时的wait、join、park方法")]),a._v(" "),n("li",[n("strong",[a._v("TIMED_WAITING")]),a._v("：线程调用了有超时的wait、sleep、join、parkNanos、parkUntil方法")]),a._v(" "),n("li",[n("strong",[a._v("TERMINATED")]),a._v("：线程终止/完成了运行")])]),a._v(" "),n("div",{staticClass:"custom-block warning"},[n("p",{staticClass:"custom-block-title"},[a._v("WARNING")]),a._v(" "),n("ul",[n("li",[a._v("synchronized锁竞争中，等待的线程的状态是BLOCKED")]),a._v(" "),n("li",[a._v("ReentrantLock锁竞争中，等待的线程状态是WAITING")])])]),a._v(" "),n("hr"),a._v(" "),n("h2",{attrs:{id:"java线程的现状与未来"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java线程的现状与未来"}},[a._v("#")]),a._v(" java线程的现状与未来")]),a._v(" "),n("ul",[n("li",[n("strong",[a._v("现状")]),a._v(" : java使用的操作系统1:1内核线程，用户和内核态切换消耗高，64位Linux线程栈默认1M(内核数据结构消耗16KB)最大支持200以内线程数")]),a._v(" "),n("li",[n("strong",[a._v("未来")]),a._v(' : Loom项目引入有栈协程，江湖人称"Fiber"纤程。这是一种用户线程，比内核线程更轻量级，单机支持更大并发数。')])]),a._v(" "),n("hr"),a._v(" "),n("h2",{attrs:{id:"线程安全"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[a._v("#")]),a._v(" 线程安全")]),a._v(" "),n("ul",[n("li",[n("p",[n("strong",[a._v("不可变")]),a._v(":"),n("br"),a._v("\n不可变对象一定是线程安全的。对final修饰的class生成的对象，并不是线程安全的，它只是不可继承。对class属性用final修饰，才能保证该对象，\n是线程的安全的，无论线程如何执行，都不会破坏对象的状态。这里还要注意，构建不可变对象的构造器，this指针不能外泄。")])]),a._v(" "),n("li",[n("p",[n("strong",[a._v("绝对线程安全")]),a._v(":"),n("br"),a._v("\n即使类的所有方法都使用synchronized同步加持，也不能保证该类绝对安全。Vector,起三个线程对其分别添加，获得，删除元素，很大概率会出现，要\n获得的元素已经被删除，从而出现下标越界错误。要保证绝对的安全，需要在各个方法内部copy一份当前对象的状态(行业特指快照),对快照执行操作，\n就能保证绝对的安全。但是执行快照需要更多的时间和空间成本。")])]),a._v(" "),n("li",[n("p",[n("strong",[a._v("相对线程安全")]),a._v(":"),n("br"),a._v("\n相对线程安全就是我们通常意义上的线程安全，它保证了对这个对象单次操作是线程安全，通常调用不需要额外保障措施。但是对于一些特定的顺序的连续调用，就可能\n需要在调用端补充额外的同步，来保证正确性。java中线程安全类都是这种类型。")])]),a._v(" "),n("li",[n("p",[n("strong",[a._v("线程兼容")]),a._v(":"),n("br"),a._v("\n线程兼容是指对象本身并不是线程安全的，但是通过在调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用。Java中大部分来都是线程兼容的，\n如HashMap，ArrayList")])]),a._v(" "),n("li",[n("p",[n("strong",[a._v("线程对立")]),a._v(":"),n("br"),a._v("\n线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。由于Java语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的\n而且通常都是有害的，应当尽量避免。线程对立的例子，Thread类的suspend()和resume()。A线程执行suspend,B线程执行resume,如果A-suspend的线程\n是B，那么B就会死锁。其他线程对立还有，System.setIn(),System.setOut和System.runFinalizersOnExit()")])])]),a._v(" "),n("h3",{attrs:{id:"线程安全的实现方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程安全的实现方法"}},[a._v("#")]),a._v(" 线程安全的实现方法")]),a._v(" "),n("ul",[n("li",[n("p",[n("strong",[a._v("互斥同步")]),a._v(":"),n("br"),a._v("\nsynchronized同步块 和 ReentrantLock非块")])]),a._v(" "),n("li",[n("p",[n("strong",[a._v("非阻塞同步")]),a._v(":"),n("br"),a._v("\n基于CAS实现的原子类，AtomicInteger等，Atomic-xx家族")])]),a._v(" "),n("li",[n("p",[n("strong",[a._v("无同步方案")]),a._v(":"),n("br"),a._v("\n当线程的数据不会被其他线程共享，只在当前线程内完成，那数据就是线程安全的。比如：消息队列的中消息，只会被一个线程取出操作。比如：\nweb应用，每个对话单独对应一个线程。单个线程内的数据，在多个方法间传递，靠的是ThreadLocalMap,内部封装一个map.它的key是\nThreadLocal.threadLocalHashCode.")])])]),a._v(" "),n("hr"),a._v(" "),n("h2",{attrs:{id:"并发安全支持"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并发安全支持"}},[a._v("#")]),a._v(" 并发安全支持")]),a._v(" "),n("h3",{attrs:{id:"volatile"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[a._v("#")]),a._v(" volatile")]),a._v(" "),n("p",[a._v("java虚拟机提供的最轻量级同步机制。")]),a._v(" "),n("ul",[n("li",[a._v("可见性")]),a._v(" "),n("li",[a._v("非原子性")]),a._v(" "),n("li",[a._v("指令禁重排")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("public class Singleton {\n    private volatile static Singleton instance;\n    \n    public static Singleton getInstance(){\n        if(instance == null){\n            synchronized(Singleton.class){\n                if(instance == null){\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public static void main(String[] args){\n        Singleton.getInstance();\n    }\n\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br")])]),n("h3",{attrs:{id:"synchronized"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#synchronized"}},[a._v("#")]),a._v(" synchronized")]),a._v(" "),n("p",[a._v("由jvm提供的字节码指令monitorenter和monitorexit实现，隐式调用了lock和unlock(java内存模型的操作)"),n("br")]),a._v(" "),n("ul",[n("li",[a._v("可见性：对一个变量执行unlock操作之前，必须先对该变量执行store,write操作。"),n("br"),a._v("\n（备注：final修饰的字段在构造器中初始化完成，如果构造器没有把this传递出去，那么该变量即拥有可见性）")]),a._v(" "),n("li",[a._v("有序性：同一时刻只允许一个线程对变量进行loca操作")]),a._v(" "),n("li",[a._v("原子性：同一时刻只有一个线程进行操作")]),a._v(" "),n("li",[a._v("重入性：对同一个线程，可以反复进入同步块。每进入一次，同步计数器加，退出一次减一，计数器归零，锁释放。")]),a._v(" "),n("li",[a._v("不可中断：外界无法强制已获得synchronized同步块锁的线程释放锁。也无法强制等待该同步块锁的线程中断等待和超时退出。")]),a._v(" "),n("li",[a._v("重量级锁")])]),a._v(" "),n("h3",{attrs:{id:"reentrantlock"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock"}},[a._v("#")]),a._v(" ReentrantLock")]),a._v(" "),n("p",[a._v("由JUC包中AbstractQueuedSynchronizer同步器实现")]),a._v(" "),n("ul",[n("li",[a._v("可见性：")]),a._v(" "),n("li",[a._v("有序性：")]),a._v(" "),n("li",[a._v("原子性：")]),a._v(" "),n("li",[a._v("可重入")]),a._v(" "),n("li",[a._v("可中断")]),a._v(" "),n("li",[a._v("可超时")]),a._v(" "),n("li",[a._v("公平锁/非公平锁(默认)")]),a._v(" "),n("li",[a._v("绑定多个条件")])]),a._v(" "),n("h3",{attrs:{id:"锁优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#锁优化"}},[a._v("#")]),a._v(" 锁优化")]),a._v(" "),n("ul",[n("li",[a._v("自旋锁：JDK1.4.2加入，需要解锁开启。在JDK1.6中是默认开启的。默认自旋是10次。")]),a._v(" "),n("li",[a._v("锁消除：JVM通过过程间分析变量逃逸，判断是否需要同步，不需要同步的，会在编译时去掉锁")]),a._v(" "),n("li",[a._v("锁粗化：如果对用一个对象的一些列操作，反复加锁释放锁，就会把锁粗化到整个系列动作的外围。比如StringBuilder.append()")]),a._v(" "),n("li",[a._v("轻量级锁：在没有多线程的情况下，减少传统重量级锁的互斥消耗。轻量级锁由对象头的mark word实现，使用了CAS。"),n("br"),a._v("\n无锁01 -> 轻量级锁00 -> 重量级锁10(发生多线程竞争)")]),a._v(" "),n("li",[a._v("偏向锁：偏向第一个获得它的线程，接下来的执行中，没有其他线程来竞争锁，，持有偏向锁的线程将永远不需要同步。请求头偏向标记，0-无偏向\n1-偏向")])]),a._v(" "),n("h2",{attrs:{id:"cas"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cas"}},[a._v("#")]),a._v(" CAS")]),a._v(" "),n("p",[a._v("Conmpare And Swap,由操作系统实现的一组操作具原子性。Java类库提供了三个native方法，它们提供了CAS方法。")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);\n\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n\npublic final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);\n\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br")])]),n("h2",{attrs:{id:"aqs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aqs"}},[a._v("#")]),a._v(" AQS")]),a._v(" "),n("p",[a._v("AbstractQueuedSynchronizer，Java并发工具类库的基础类，同步器。")]),a._v(" "),n("ul",[n("li",[a._v("独占锁实现：state=0锁可用，state=1 锁占用")]),a._v(" "),n("li",[a._v("共享锁实现：state=初始值，锁可被获取的次数。state=0,无锁可用。")]),a._v(" "),n("li",[a._v("node双端队列，实现FIFO。head节点不包含线程，只作为队列的头，前一个节点保存下一个节点的状态。")]),a._v(" "),n("li",[a._v("节点变更使用CAS")]),a._v(" "),n("li",[a._v("状态变更使用CAS")]),a._v(" "),n("li",[a._v("AQS线程阻塞/唤醒靠LockSupport,阻塞park(),唤醒unpark()")]),a._v(" "),n("li",[a._v("锁条件接口Condition")])]),a._v(" "),n("h2",{attrs:{id:"juc并发工具类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#juc并发工具类"}},[a._v("#")]),a._v(" JUC并发工具类")]),a._v(" "),n("h3",{attrs:{id:"countdownlatch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch"}},[a._v("#")]),a._v(" CountDownLatch")]),a._v(" "),n("p",[a._v("允许一个或多个线程等待其他线程完成操作。")]),a._v(" "),n("ul",[n("li",[a._v("await()方法阻塞调用线程，入队")]),a._v(" "),n("li",[a._v("countDown()方法使aqs状态state-1,state=0时，设置head节点状态-3(由此，队列中阻塞的线程都可以获得共享式同步状态)")])]),a._v(" "),n("h3",{attrs:{id:"cyclicbarrier"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier"}},[a._v("#")]),a._v(" CyclicBarrier")]),a._v(" "),n("p",[a._v("一组线程到达一个屏障时都被阻塞，最后一个到达的线程触发屏障开启，所有线程通过。一起在某个屏障阻塞，然后一起通过。这个过程反复建立。")]),a._v(" "),n("ul",[n("li",[a._v("ReentrantLock")]),a._v(" "),n("li",[a._v("核心实现是Condition,在同一个条件上阻塞，然后由这个条件统一唤醒。")])]),a._v(" "),n("h3",{attrs:{id:"semaohore"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#semaohore"}},[a._v("#")]),a._v(" Semaohore")]),a._v(" "),n("p",[a._v("信号量用来控制同时访问特定资源的线程数量，可以实现池的功能。")]),a._v(" "),n("ul",[n("li",[a._v("由AQS的共享锁实现")]),a._v(" "),n("li",[a._v("state需要初始化可获得的锁，没获得一个锁，state-1.state=0时，无锁可用，线程进入队列。")])]),a._v(" "),n("h3",{attrs:{id:"exchanger"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exchanger"}},[a._v("#")]),a._v(" Exchanger")]),a._v(" "),n("p",[a._v("用于线程间的数据交换，第一个线程先执行exchange(),然后阻塞等待。第二个线程也执行exchange方法，这时两个线程\n都到达了同步点，然后交换数据。")]),a._v(" "),n("ul",[n("li",[a._v("ThreadLocalMap")])]),a._v(" "),n("h2",{attrs:{id:"并发安全容器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并发安全容器"}},[a._v("#")]),a._v(" 并发安全容器")]),a._v(" "),n("h3",{attrs:{id:"concurrenthashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),n("ul",[n("li",[a._v("分段锁实现安全")]),a._v(" "),n("li",[a._v("JDK7实现：Segment(ReentrantLock),两次hash,第一次hash定位到Segment数组，第二次hash定位到链表的头部元素"),n("br"),a._v("\n缺点：多了一次hash的消耗"),n("br"),a._v(" "),n("img",{attrs:{src:"/images/interview/iw-5.png",alt:""}})]),a._v(" "),n("li",[a._v("JDK8实现：synchronized + CAS + HashEntry + 红黑树，一次hash定位到链表头部元素，对这个元素加锁。")])]),a._v(" "),n("h3",{attrs:{id:"concurrentlinkedqueue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#concurrentlinkedqueue"}},[a._v("#")]),a._v(" ConcurrentLinkedQueue")]),a._v(" "),n("h3",{attrs:{id:"阻塞队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列"}},[a._v("#")]),a._v(" 阻塞队列")]),a._v(" "),n("ul",[n("li",[a._v("ArrayBlockingQueue 数组结构组成的有界阻塞队列")]),a._v(" "),n("li",[a._v("LinkedBlockingQueue 链表结构组成的有界阻塞队列")]),a._v(" "),n("li",[a._v("PriorityBlockingQueue 支持优先级无界阻塞队列")]),a._v(" "),n("li",[a._v("DelayQueue 使用优先级队列实现的无界阻塞队列")]),a._v(" "),n("li",[a._v("SynchronousQueue 不存储元素的阻塞队列")]),a._v(" "),n("li",[a._v("LinkedTransferQueue 链表结构组成的无界阻塞队列")]),a._v(" "),n("li",[a._v("LinkedBlockingDueue 链表结构组成的双向阻塞队列")])]),a._v(" "),n("h3",{attrs:{id:"collections安全容器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#collections安全容器"}},[a._v("#")]),a._v(" Collections安全容器")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("List safeArrayList = Collections.synchronizedList(new ArrayList<>());\nList safeLinkedList = Collections.synchronizedList(new LinkedList<>());\nSet safeLinkedHashSet = Collections.synchronizedSet(new LinkedHashSet<>());\nSet safeTreeSet = Collections.synchronizedSet(new TreeSet<>());\nSet safeHashSet = Collections.synchronizedSet(new HashSet<>());\nMap safeHashMap = Collections.synchronizedMap(new HashMap<>());\nMap safeTreeMap = Collections.synchronizedMap(new TreeMap<>());\nMap safeLinkedHashMap = Collections.synchronizedMap(new LinkedHashMap<>());\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br")])]),n("h3",{attrs:{id:"fork-join"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fork-join"}},[a._v("#")]),a._v(" Fork/Join")]),a._v(" "),n("p",[a._v("fork/join是JDK7提供的一个用于并行执行任务的框架。是一个把大人物分割成若干个小人物，最终汇总每个小人物结果后得到大人物结果的框架。")]),a._v(" "),n("ul",[n("li",[n("p",[a._v("工作窃取算法")]),a._v(" "),n("ul",[n("li",[a._v("工作窃取算法是指某个线程从其他队列里窃取任务来执行。")]),a._v(" "),n("li",[a._v("工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。")]),a._v(" "),n("li",[a._v("工作窃取算法的缺点：在某些情况还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗更多的系统资源，比如创建多个线程和多个\n双端队列。")])])]),a._v(" "),n("li",[n("p",[a._v("实现任务")]),a._v(" "),n("ul",[n("li",[a._v("步骤一：分割任务"),n("br"),a._v("\n首先需要一个fork类来把大人物分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。")]),a._v(" "),n("li",[a._v("步骤二：执行任务并合并结果"),n("br"),a._v("\n分割的子任务分别放在双端队列里，然后几个启动线程分别从双队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程\n从队列里拿数据，然后合并这些数据。")])])]),a._v(" "),n("li",[n("p",[a._v("fork/join 使用两个类来完成以上两件事情")]),a._v(" "),n("ul",[n("li",[a._v("ForkJoinTask : 使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join操作的机制。通常情况下，\n不需要直接继承ForkJoinTask类，只需要继承它的子类，fork/join框架提供了以下两个子类。\n"),n("ul",[n("li",[a._v("RecursiveAction: 用于没有返回结果的任务")]),a._v(" "),n("li",[a._v("RecursiveTask: 用于有返回结果的任务")])])]),a._v(" "),n("li",[a._v("ForkJoinPool : ForkJoinTask需要通过ForkJoinPool来执行"),n("br"),a._v(" "),n("ul",[n("li",[a._v("任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他\n工作线程的队列尾部获取一个任务")])])])])]),a._v(" "),n("li",[n("p",[a._v("fork/join框架的异常处理")]),a._v(" "),n("ul",[n("li",[a._v("ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以在ForkJoinTask提供了isCompletedAbnormally()\n方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。getException方法返回Throwable\n对象，如果任务被取消了则放回CancellationException。如果任务没有完成或者没有抛出异常则返回null。"),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("if(task.isCompletedAbnormally){\n    System.out.println(task.getException());\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br")])])])])])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("class SumTask extends RecursiveTask<Integer> {\n\n    private static final Integer FLAG = 2;\n\n    private int start, end;\n\n    public SumTask(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Integer compute() {\n        int sum = 0;\n        boolean canCompute = (end - start) <= FLAG;\n        if (canCompute) {\n            for (int i = start; i <= end; i++) {\n                sum += i;\n            }\n        } else {\n            int mid = (start + end) / 2;\n            SumTask sumLeft = new SumTask(start, mid);\n            SumTask sumRight = new SumTask(mid + 1, end);\n            sumLeft.fork();\n            sumRight.fork();\n            int leftSum = sumLeft.join();\n            int rightSum = sumRight.join();\n            sum = leftSum + rightSum;\n        }\n        return sum;\n    }\n}\n\npublic class ForkJoinDemo {\n\n    public static void main(String[] args) {\n        ForkJoinPool pool = new ForkJoinPool();\n        SumTask task = new SumTask(1,9);\n\n        Future<Integer> result = pool.submit(task);\n\n        try {\n            System.out.println(result.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br"),n("span",{staticClass:"line-number"},[a._v("31")]),n("br"),n("span",{staticClass:"line-number"},[a._v("32")]),n("br"),n("span",{staticClass:"line-number"},[a._v("33")]),n("br"),n("span",{staticClass:"line-number"},[a._v("34")]),n("br"),n("span",{staticClass:"line-number"},[a._v("35")]),n("br"),n("span",{staticClass:"line-number"},[a._v("36")]),n("br"),n("span",{staticClass:"line-number"},[a._v("37")]),n("br"),n("span",{staticClass:"line-number"},[a._v("38")]),n("br"),n("span",{staticClass:"line-number"},[a._v("39")]),n("br"),n("span",{staticClass:"line-number"},[a._v("40")]),n("br"),n("span",{staticClass:"line-number"},[a._v("41")]),n("br"),n("span",{staticClass:"line-number"},[a._v("42")]),n("br"),n("span",{staticClass:"line-number"},[a._v("43")]),n("br"),n("span",{staticClass:"line-number"},[a._v("44")]),n("br"),n("span",{staticClass:"line-number"},[a._v("45")]),n("br"),n("span",{staticClass:"line-number"},[a._v("46")]),n("br"),n("span",{staticClass:"line-number"},[a._v("47")]),n("br"),n("span",{staticClass:"line-number"},[a._v("48")]),n("br"),n("span",{staticClass:"line-number"},[a._v("49")]),n("br"),n("span",{staticClass:"line-number"},[a._v("50")]),n("br")])]),n("h2",{attrs:{id:"线程池"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[a._v("#")]),a._v(" 线程池")]),a._v(" "),n("h3",{attrs:{id:"线程池的创建"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程池的创建"}},[a._v("#")]),a._v(" 线程池的创建")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v(" new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,milliseconds,runnableTaskQueue,handler);\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("ul",[n("li",[a._v("corePoolSize: 核心线程数，提交一个任务，就创建一个核心线程来执行，直到达到最大核心线程数")]),a._v(" "),n("li",[a._v("runnableTaskQueue: 核心线程数数达到最大，来不及处理的任务，就丢到任务队列里面阻塞，等到核心线程空闲出来再取出执行"),n("br"),a._v("\nArrayBlockingQueue 基于数组的有界阻塞队列，FIFO排序元素"),n("br"),a._v("\nLinkedBlockingQueue 基于链表的阻塞队列，按照FIFO排序元素"),n("br"),a._v("\nSynchronousQueue 不存储元素的阻塞队列，必须有线程空闲，否则插入新任务一直阻塞"),n("br"),a._v("\nPriorityBlockingQueue优先级策略的无界阻塞队列")]),a._v(" "),n("li",[a._v("maximumPoolSize: 任务队列满了就会创建非核心线程来处理任务。直到达到最大数量。")]),a._v(" "),n("li",[a._v("ThreadFactory 创建线程的工厂")]),a._v(" "),n("li",[a._v("RejectedExecutionHandler 非核心线程满载也不能使任务队列爆满，就触发饱和策略"),n("br"),a._v("\nAbortPolicy 直接抛出异常"),n("br"),a._v("\nCallerRunsPolicy 只用调用者所在的线程来运行任务"),n("br"),a._v("\nDiscardOldestPolicy 丢弃任务队列里的最近的一个任务，并执行当前任务"),n("br"),a._v("\nDiscardPolicy 不处理，直接丢弃")]),a._v(" "),n("li",[a._v("keepAliveTime 线程池的线程空闲状态能维持的最大存活时间")]),a._v(" "),n("li",[a._v("TimeUnit 存活时间单位")])]),a._v(" "),n("h3",{attrs:{id:"关闭线程池"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关闭线程池"}},[a._v("#")]),a._v(" 关闭线程池")]),a._v(" "),n("p",[a._v("共同特征：遍历线程池中的工作线程，逐个调用线程的interrupt方法中断线程")]),a._v(" "),n("ul",[n("li",[a._v("shutdownNow 先设置线程池状态STOP，尝试停止所有正在执行或者暂停的线程")]),a._v(" "),n("li",[a._v("shutdownNow 先设置线程状态Shutdown ,然后中断所有没有在执行任务的线程")])]),a._v(" "),n("h2",{attrs:{id:"executor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#executor"}},[a._v("#")]),a._v(" Executor")]),a._v(" "),n("h3",{attrs:{id:"结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[a._v("#")]),a._v(" 结构")]),a._v(" "),n("ul",[n("li",[a._v("任务：实现Runnable或Callable接口")]),a._v(" "),n("li",[a._v("任务的执行: 核心接口类Executor,关键实现类ThreadPoolExecutor和ScheduledThreadPoolExecutor"),n("br"),a._v(" "),n("img",{attrs:{src:"/images/interview/iw-3.png",alt:""}})]),a._v(" "),n("li",[a._v("异步计算的结果：接口Future和实现类FutureTask"),n("br"),a._v(" "),n("img",{attrs:{src:"/images/interview/iw-4.png",alt:""}})])]),a._v(" "),n("h3",{attrs:{id:"关键接口和实现类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关键接口和实现类"}},[a._v("#")]),a._v(" 关键接口和实现类")]),a._v(" "),n("ul",[n("li",[a._v("Executor 接口，制定标准，将任务的提交与任务的执行分离开来。")]),a._v(" "),n("li",[a._v("ThreadPoolExecutor 线程池的核心实现类，用来提交任务")]),a._v(" "),n("li",[a._v("ScheduledThreadPoolExecutor 可以在给定的延迟后运行命令，或定期执行。")]),a._v(" "),n("li",[a._v("Future 代表异步执行的结果")]),a._v(" "),n("li",[a._v("Runnable 实现类代表无结果返回的任务")]),a._v(" "),n("li",[a._v("Callable 实现类代表有结果返回，用Future/FutureTask接收结果，异步")])]),a._v(" "),n("h3",{attrs:{id:"框架成员"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#框架成员"}},[a._v("#")]),a._v(" 框架成员")]),a._v(" "),n("ul",[n("li",[a._v("ThreadPoolExecutor，用工厂类Executors来创建"),n("br"),a._v(" "),n("ol",[n("li",[a._v("FixedThreadPool 固定线程数，适合负载较重的服务器，用来满足对资源的管理"),n("br")]),a._v(" "),n("li",[a._v("SingleThreadExecutor 单个线程，用于需要保证顺序执行的任务"),n("br")]),a._v(" "),n("li",[a._v("CachedThreadPool 最大线程数integer.max,无界任务队列(链表)"),n("br")])])]),a._v(" "),n("li",[a._v("ScheduledThreadPoolExecutor"),n("br"),a._v(" "),n("ol",[n("li",[a._v("ScheduledThreadPoolExecutor 有若干个线程")]),a._v(" "),n("li",[a._v("SingleThreadScheduledExecutor 只有一个线程的ScheduledThreadPoolExecutor")])])]),a._v(" "),n("li",[a._v("Future接口 实现类FutureTask 接收异步执行的结果")]),a._v(" "),n("li",[a._v("Runnable 实现类代表无结果返回的任务")]),a._v(" "),n("li",[a._v("Callable 实现类代表有结果返回，用Future/FutureTask接收结果，异步")])])])}),[],!1,null,null,null);s.default=t.exports}}]);