(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{424:function(s,e,a){"use strict";a.r(e);var n=a(42),t=Object(n.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"redis使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis使用"}},[s._v("#")]),s._v(" redis使用")]),s._v(" "),a("hr"),s._v(" "),a("h2",{attrs:{id:"redis简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis简介"}},[s._v("#")]),s._v(" redis简介")]),s._v(" "),a("h3",{attrs:{id:"什么是-redis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-redis"}},[s._v("#")]),s._v(" 什么是 Redis？")]),s._v(" "),a("ul",[a("li",[s._v("Redis 是用 C 语言开发的一个开源的高性能键值对（key-value） 内存数据库。")]),s._v(" "),a("li",[s._v("它提供五种数据类型来存储值： 字符串类型、 散列类型、 列表类型、 集合类型、 有序\n集合类型")]),s._v(" "),a("li",[s._v("它是一种 NoSQL 数据库。")])]),s._v(" "),a("h3",{attrs:{id:"什么是-nosql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-nosql"}},[s._v("#")]),s._v(" 什么是 NoSQL？")]),s._v(" "),a("ul",[a("li",[s._v("NoSQL，即 Not-Only SQL（不仅仅是 SQL），泛指非关系型的数据库。")]),s._v(" "),a("li",[s._v("什么是关系型数据库？ 数据结构是一种有行有列的数据库")]),s._v(" "),a("li",[s._v("NoSQL 数据库是为了解决高并发、高可用、高可扩展、大数据存储问题而产生的\n数据库解决方案。")]),s._v(" "),a("li",[s._v("NoSQL 可以作为关系型数据库的良好补充，但是不能替代关系型数据库。")])]),s._v(" "),a("h3",{attrs:{id:"redis应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis应用场景"}},[s._v("#")]),s._v(" redis应用场景")]),s._v(" "),a("ul",[a("li",[s._v("内存数据库（登录信息、购物车信息、 用户浏览记录等）")]),s._v(" "),a("li",[s._v("缓存服务器（商品数据、 广告数据等等）。（最多使用）")]),s._v(" "),a("li",[s._v("解决分布式集群架构中的 session 分离问题（session 共享）。")]),s._v(" "),a("li",[s._v("任务队列。（秒杀、抢购、 12306 等等）")]),s._v(" "),a("li",[s._v("支持发布订阅的消息模式")]),s._v(" "),a("li",[s._v("应用排行榜。")]),s._v(" "),a("li",[s._v("网站访问统计。")]),s._v(" "),a("li",[s._v("数据过期处理（可以精确到毫秒）")])]),s._v(" "),a("h2",{attrs:{id:"redis数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis数据结构"}},[s._v("#")]),s._v(" redis数据结构")]),s._v(" "),a("h3",{attrs:{id:"string"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[s._v("#")]),s._v(" String")]),s._v(" "),a("h3",{attrs:{id:"hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[s._v("#")]),s._v(" Hash")]),s._v(" "),a("h3",{attrs:{id:"list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[s._v("#")]),s._v(" List")]),s._v(" "),a("h3",{attrs:{id:"set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[s._v("#")]),s._v(" Set")]),s._v(" "),a("h3",{attrs:{id:"sortedset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sortedset"}},[s._v("#")]),s._v(" SortedSet")]),s._v(" "),a("h2",{attrs:{id:"分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[s._v("#")]),s._v(" 分布式锁")]),s._v(" "),a("ul",[a("li",[s._v("互斥性： 在任意时刻，只有一个客户端能持有锁")]),s._v(" "),a("li",[s._v("同一性： 加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。")]),s._v(" "),a("li",[s._v("可重入性： 即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。")])]),s._v(" "),a("h3",{attrs:{id:"获取锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取锁"}},[s._v("#")]),s._v(" 获取锁")]),s._v(" "),a("ul",[a("li",[s._v("SET KEY VALUE [EX seconds] [PX milliseconds] [NX|XX]\n"),a("ul",[a("li",[s._v("EX seconds 设置指定的到期时间(单位s)")]),s._v(" "),a("li",[s._v("PX milliseconds 设置指定的到期时间(单位ms)")]),s._v(" "),a("li",[s._v("NX 仅在键不存在时设置键")]),s._v(" "),a("li",[s._v("XX 仅在键已存在时设置键"),a("br")])])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('/**\n* 使用redis的set命令实现获取分布式锁\n* @param lockKey 可以就是锁\n* @param requestId 请求ID，保证同一性\n* @param expireTime 过期时间，避免死锁\n* @return\n*/\npublic static boolean getLock(String lockKey,String requestId,int expireTime) {\n   //NX:保证互斥性\n   String result = jedis.set(lockKey, requestId, "NX", "EX", expireTime);\n   if("OK".equals(result)) {\n       return true;\n   }\n   return false;\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("ul",[a("li",[s._v("SETNX (不推荐，不具有原子性)")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("public static boolean getLock(String lockKey,String requestId,int expireTime) {\n    Long result = jedis.setnx(lockKey, requestId);\n    if(result == 1) {\n        jedis.expire(lockKey, expireTime);\n        return true;\n    }\n    return false;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h3",{attrs:{id:"释放锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#释放锁"}},[s._v("#")]),s._v(" 释放锁")]),s._v(" "),a("ul",[a("li",[s._v("redis+lua (推荐)")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("public static boolean releaseLock(String lockKey, String requestId) {\n    String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then \n                    return redis.call('del', KEYS[1]) else return 0 end\";\n    Object result = jedis.eval(script, Collections.singletonList(lockKey),\n    Collections.singletonList(requestId));\n    if (result.equals(1L)) {\n        return true;\n    }\n    return false;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("ul",[a("li",[s._v("del")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("/**\n* 释放分布式锁\n* @param lockKey\n* @param requestId\n*/\npublic static void releaseLock(String lockKey,String requestId) {\n    if (requestId.equals(jedis.get(lockKey))) {\n        jedis.del(lockKey);\n    }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("h2",{attrs:{id:"使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[s._v("#")]),s._v(" 使用")]),s._v(" "),a("h3",{attrs:{id:"jedis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jedis"}},[s._v("#")]),s._v(" jedis")]),s._v(" "),a("h2",{attrs:{id:"过期策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过期策略"}},[s._v("#")]),s._v(" 过期策略")]),s._v(" "),a("h3",{attrs:{id:"redis-内置缓存淘汰策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-内置缓存淘汰策略"}},[s._v("#")]),s._v(" Redis 内置缓存淘汰策略")]),s._v(" "),a("ul",[a("li",[s._v("最大缓存\n"),a("ul",[a("li",[s._v("在 redis 中，允许用户设置最大使用内存大小 maxmemory，默认为 0，没有指定\n最大缓存，如果有新的数据添加，超过最大内存，则会使 redis 崩溃，所以一定要设置。")]),s._v(" "),a("li",[s._v("redis 内存数据集大小上升到一定大小的时候，就会实行数据淘汰策略。")])])]),s._v(" "),a("li",[s._v("淘汰策略\n"),a("ul",[a("li",[s._v("redis 淘汰策略配置： maxmemory-policy voltile-lru，支持热配置")])])]),s._v(" "),a("li",[s._v("redis 提供 6 种数据淘汰策略：\n"),a("ul",[a("li",[s._v("voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近\n最少使用的数据淘汰")]),s._v(" "),a("li",[s._v("volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要\n过期的数据淘汰")]),s._v(" "),a("li",[s._v("volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任\n意选择数据淘汰")]),s._v(" "),a("li",[s._v("allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰")]),s._v(" "),a("li",[s._v("allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰")]),s._v(" "),a("li",[s._v("no-enviction（驱逐）：禁止驱逐数据")])])])]),s._v(" "),a("h3",{attrs:{id:"lru-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lru-原理"}},[s._v("#")]),s._v(" LRU 原理")]),s._v(" "),a("p",[s._v("LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数\n据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高” 。")]),s._v(" "),a("h3",{attrs:{id:"lru-实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lru-实现"}},[s._v("#")]),s._v(" LRU 实现")]),s._v(" "),a("p",[s._v("最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：\n"),a("img",{attrs:{src:"/images/interview/redis-1.png",alt:""}}),a("br")]),s._v(" "),a("ol",[a("li",[s._v("新数据插入到链表头部；")]),s._v(" "),a("li",[s._v("每当缓存命中（即缓存数据被访问），则将数据移到链表头部；")]),s._v(" "),a("li",[s._v("当链表满的时候，将链表尾部的数据丢弃。\n在 Java 中可以使用 LinkHashMap 去实现 LRU。")])]),s._v(" "),a("h3",{attrs:{id:"分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分析"}},[s._v("#")]),s._v(" 分析")]),s._v(" "),a("ul",[a("li",[s._v("命中率\n"),a("ul",[a("li",[s._v("当存在热点数据时， LRU 的效率很好，但偶发性的、周期性的批量操作会导致 LRU 命中\n率急剧下降，缓存污染情况比较严重。")])])]),s._v(" "),a("li",[s._v("复杂度】\n"),a("ul",[a("li",[s._v("实现简单。")])])]),s._v(" "),a("li",[s._v("代价】\n"),a("ul",[a("li",[s._v("命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部")])])])]),s._v(" "),a("h2",{attrs:{id:"缓存陷进问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存陷进问题"}},[s._v("#")]),s._v(" 缓存陷进问题")]),s._v(" "),a("h3",{attrs:{id:"缓存穿透"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[s._v("#")]),s._v(" 缓存穿透")]),s._v(" "),a("ul",[a("li",[s._v("什么叫缓存穿透？"),a("br"),s._v("\n一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端系统\n查找（比如 DB）。如果 key 对应的 value 是一定不存在的，并且对该 key 并发请求量很大，\n就会对后端系统造成很大的压力。这就叫做缓存穿透。")]),s._v(" "),a("li",[s._v("如何解决\n"),a("ul",[a("li",[s._v("1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert了之后清理缓存。")]),s._v(" "),a("li",[s._v("2：对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，\n查询时通过该 bitmap 过滤。（布隆表达式）")])])])]),s._v(" "),a("h3",{attrs:{id:"缓存雪崩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[s._v("#")]),s._v(" 缓存雪崩")]),s._v(" "),a("ul",[a("li",[s._v("什么叫缓存雪崩？\n当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端\n系统(比如 DB)带来很大压力。")]),s._v(" "),a("li",[s._v("如何解决？\n"),a("ul",[a("li",[s._v("1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key\n只允许一个线程查询数据和写缓存，其他线程等待。")]),s._v(" "),a("li",[s._v("2：不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀。")]),s._v(" "),a("li",[s._v("3：做二级缓存， A1 为原始缓存， A2 为拷贝缓存， A1 失效时，可以访问 A2， A1 缓存失\n效时间设置为短期， A2 设置为长期（此点为补充）")])])])]),s._v(" "),a("h3",{attrs:{id:"缓存击穿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[s._v("#")]),s._v(" 缓存击穿")]),s._v(" "),a("ul",[a("li",[s._v("什么叫缓存击穿？\n"),a("ul",[a("li",[s._v("对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，\n是一种非常“热点” 的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个\n和缓存雪崩的区别在于这里针对某一 key 缓存，前者则是很多 key。")]),s._v(" "),a("li",[s._v("缓存在某个时间点过期的时候，恰好在这个时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求\n可能会瞬间把后端 DB 压垮。")])])]),s._v(" "),a("li",[s._v("如何解决？\n使用 redis 的 setnx 互斥锁先进行判断，这样其他线程就处于等待状态，保证不会有大并\n发操作去操作数据库。")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("if(redis.sexnx()==1){\n    //查询数据库\n    //加入线程\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h2",{attrs:{id:"cas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cas"}},[s._v("#")]),s._v(" CAS")]),s._v(" "),a("h3",{attrs:{id:"_64"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_64"}},[s._v("#")]),s._v(" 64")]),s._v(" "),a("h2",{attrs:{id:"持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[s._v("#")]),s._v(" 持久化")]),s._v(" "),a("h3",{attrs:{id:"rdb方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb方式"}},[s._v("#")]),s._v(" RDB方式")]),s._v(" "),a("h4",{attrs:{id:"使用介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用介绍"}},[s._v("#")]),s._v(" 使用介绍")]),s._v(" "),a("ul",[a("li",[s._v("RDB 是 Redis 默认采用的持久化方式。")]),s._v(" "),a("li",[s._v("RDB 方式是通过快照（snapshotting）完成的，当符合一定条件时 Redis 会自动将内\n存中的数据进行快照并持久化到硬盘。")]),s._v(" "),a("li",[s._v("Redis 会在指定的情况下触发快照\n"),a("ul",[a("li",[s._v("符合自定义配置的快照规则")]),s._v(" "),a("li",[s._v("执行 save 或者 bgsave 命令")]),s._v(" "),a("li",[s._v("执行 flushall 命令")]),s._v(" "),a("li",[s._v("执行主从复制操作")])])]),s._v(" "),a("li",[s._v("在 redis.conf 中设置自定义快照规则")]),s._v(" "),a("li",[s._v("1.RDB持久化条件\n"),a("ul",[a("li",[s._v("格式： save <seconds> <changes>")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("save 900 1 ： 表示 15 分钟（900 秒钟）内至少 1 个键被更改则进行快照。\nsave 300 10 ： 表示 5 分钟（300 秒）内至少 10 个键被更改则进行快照。\nsave 60 10000 ： 表示 1 分钟内至少 10000 个键被更改则进行快照。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),s._v("可以配置多个条件（每行配置一个条件），每个条件之间是“或” 的关系。")]),s._v(" "),a("li",[s._v("2.配置 dir 指定 rdb 快照文件的位置")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# Note that you must specify a directory here, not a file name.\ndir ./\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("3.配置 dbfilename 指定 rdb 快照文件的名称")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# The filename where to dump the DB\ndbfilename dump.rdb\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("特别说明：\n"),a("ul",[a("li",[s._v("Redis 启动后会读取 RDB 快照文件，将数据从硬盘载入到内存。")]),s._v(" "),a("li",[s._v("根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字\n符串类型键、大小为 1GB 的快照文件载入到内存中需要花费 20～30 秒钟。")])])])]),s._v(" "),a("h4",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[s._v("#")]),s._v(" 原理")]),s._v(" "),a("ul",[a("li",[s._v("快照过程\n"),a("ul",[a("li",[a("ol",[a("li",[s._v("redis 使用 fork 函数复制一份当前进程的副本(子进程)")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[s._v("父进程继续接收并处理客户端发来的命令，而子进程开始\n将内存中的数据写入硬盘中的临时文件。")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[s._v("当子进程写入完所有数据后会用该临时文件替换旧的 RDB\n文件，至此，一次快照操作完成。")])])])])]),s._v(" "),a("li",[s._v("注意事项\n"),a("ul",[a("li",[a("ol",[a("li",[s._v("redis 在进行快照的过程中不会修改 RDB 文件，只有快照\n结束后才会将旧的文件替换成新的，也就是说任何时候\nRDB 文件都是完整的。")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[s._v("这就使得我们可以通过定时备份 RDB 文件来实现 redis 数\n据库的备份， RDB 文件是经过压缩的二进制文件，占用的\n空间会小于内存中的数据，更加利于传输。")])])])])])]),s._v(" "),a("h4",{attrs:{id:"rdb优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb优缺点"}},[s._v("#")]),s._v(" RDB优缺点")]),s._v(" "),a("ul",[a("li",[s._v("缺点"),a("br"),s._v("\n使用 RDB 方式实现持久化，一旦 Redis 异常退出，就会丢失最后一次快照\n以后更改的所有数据。这个时候我们就需要根据具体的应用场景，通过组合设置自动快\n照条件的方式来将可能发生的数据损失控制在能够接受范围。如果数据相对来说比较重\n要，希望将损失降到最小，则可以使用 AOF 方式进行持久化")]),s._v(" "),a("li",[s._v("优点"),a("br"),s._v("\nRDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是\nfork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无序执\n行任何磁盘 I/O 操作。同时这个也是一个缺点，如果数据集比较大的时候， fork 可以\n能比较耗时，造成服务器在一段时间内停止处理客户端的请求；")])]),s._v(" "),a("h3",{attrs:{id:"aof方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof方式"}},[s._v("#")]),s._v(" AOF方式")]),s._v(" "),a("h4",{attrs:{id:"使用介绍-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用介绍-2"}},[s._v("#")]),s._v(" 使用介绍")]),s._v(" "),a("ul",[a("li",[s._v("默认情况下 Redis 没有开启 AOF（append only file）方式的持久化")]),s._v(" "),a("li",[s._v("开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令， Redis 就会将该命令写入硬盘中的 AOF 文件，这一过程显然会降低 Redis 的性能，但大部分情况下这个影响\n是能够接受的，另外使用较快的硬盘可以提高 AOF 的性能。")]),s._v(" "),a("li",[s._v("可以通过修改 redis.conf 配置文件中的 appendonly 参数开启"),a("br"),s._v("\nappendonly yes")]),s._v(" "),a("li",[s._v("AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的。"),a("br"),s._v("\ndir ./")]),s._v(" "),a("li",[s._v("默认的文件名是 appendonly.aof，可以通过 appendfilename 参数修改："),a("br"),s._v("\nappendfilename appendonly.aof")])]),s._v(" "),a("h4",{attrs:{id:"aof重写原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof重写原理"}},[s._v("#")]),s._v(" AOF重写原理")]),s._v(" "),a("ul",[a("li",[s._v("Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写")]),s._v(" "),a("li",[s._v("重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。")]),s._v(" "),a("li",[s._v("整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命\n令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会\n丢失。 而一旦新 AOF 文件创建完毕， Redis 就会从旧 AOF 文件切换到新 AOF 文\n件，并开始对新 AOF 文件进行追加操作。")]),s._v(" "),a("li",[s._v("AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议\n的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）\n也很轻松")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# auto-aof-rewrite-percentage 100 \n表示当前 aof 文件大小超过上一次 aof 文件大小的百分之多少的时候会进行重写。\n如果之前没有重写过，以启动时 aof 文件大小为准\n\n# auto-aof-rewrite-min-size 64mb \n限制允许重写最小 aof 文件大小，也就是文件大小小于 64mb 的时候，不需要进行优化\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h4",{attrs:{id:"同步磁盘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步磁盘"}},[s._v("#")]),s._v(" 同步磁盘")]),s._v(" "),a("p",[s._v("Redis 每次更改数据的时候， aof 机制都会将命令记录到 aof 文件，但是实际上由于操作\n系统的缓存机制， 数据并没有实时写入到硬盘，而是进入硬盘缓存。 再通过硬盘缓存机制去\n刷新到保存到文件")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("参数说明：")]),s._v(" "),a("ul",[a("li",[s._v("appendfsync always 每次执行写入都会进行同步 ， 这个是最安全但是是效率比较\n低的方式")]),s._v(" "),a("li",[s._v("appendfsync everysec 每一秒执行")]),s._v(" "),a("li",[s._v("appendfsync no 不主动进行同步操作，由操作系统去执行，这个是最快但是最不安\n全的方式")])])]),s._v(" "),a("li",[a("p",[s._v("AOF文件损坏以后如何修复"),a("br"),s._v("\n服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错\n（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性\n不会被破坏。")])]),s._v(" "),a("li",[a("p",[s._v("当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：")]),s._v(" "),a("ul",[a("li",[a("ol",[a("li",[s._v("为现有的 AOF 文件创建一个备份。")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[s._v("使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。")])])]),s._v(" "),a("li",[s._v("redis-check-aof --fix readonly.aof")]),s._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[s._v("重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。")])])])])])]),s._v(" "),a("h3",{attrs:{id:"如何选择rdb-和-aof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何选择rdb-和-aof"}},[s._v("#")]),s._v(" 如何选择RDB 和 AOF")]),s._v(" "),a("ul",[a("li",[s._v("一般来说,如果对数据的安全性要求非常高的话， 应该同时使用两种持久化功能。")]),s._v(" "),a("li",[s._v("如果可以承受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。")]),s._v(" "),a("li",[s._v("有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照\n（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF\n恢复的速度要快 。")]),s._v(" "),a("li",[s._v("两种持久化策略可以同时使用，也可以使用其中一种。如果同时使用的话， 那么 Redis\n重启时，会优先使用 AOF 文件来还原数据")])]),s._v(" "),a("h2",{attrs:{id:"主从复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从复制"}},[s._v("#")]),s._v(" 主从复制")]),s._v(" "),a("h3",{attrs:{id:"什么是主从复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是主从复制"}},[s._v("#")]),s._v(" 什么是主从复制")]),s._v(" "),a("p",[s._v("持久化保证了即使 redis 服务重启也不会丢失数据，因为 redis 服务重启后会将硬盘上\n持久化的数据恢复到内存中，但是当 redis 服务器的硬盘损坏了可能会导致数据丢失，不过\n通过 redis 的主从复制机制就可以避免这种单点故障，如下图：\n"),a("img",{attrs:{src:"/images/interview/redis-2.png",alt:""}}),a("br"),s._v("\n说明：")]),s._v(" "),a("ul",[a("li",[s._v("主 redis 中的数据有两个副本（replication）即从 redis1 和从 redis2，即使一台 redis\n服务器宕机其它两台 redis 服务也可以继续提供服务。")]),s._v(" "),a("li",[s._v("主 redis 中的数据和从 redis 上的数据保持实时同步，当主 redis 写入数据时通过主从\n复制机制会复制到两个从 redis 服务上。")]),s._v(" "),a("li",[s._v("只有一个主 redis，可以有多个从 redis。")]),s._v(" "),a("li",[s._v("主从复制不会阻塞 master，在同步数据时， master 可以继续处理 client 请求")]),s._v(" "),a("li",[s._v("一个 redis 可以即是主又是从，如下图：\n"),a("img",{attrs:{src:"/images/interview/redis-3.png",alt:""}}),a("br")])]),s._v(" "),a("h3",{attrs:{id:"主从配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从配置"}},[s._v("#")]),s._v(" 主从配置")]),s._v(" "),a("ul",[a("li",[s._v("主 redis 配置\n"),a("ul",[a("li",[s._v("无需特殊配置。")])])]),s._v(" "),a("li",[s._v("从 redis 配置\n"),a("ul",[a("li",[s._v("修改从服务器上的 redis.conf 文件")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# slaveof <masterip> <masterport>\n$ slaveof 192.168.101.3 6379\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])])])]),s._v(" "),a("h3",{attrs:{id:"实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[s._v("#")]),s._v(" 实现原理")]),s._v(" "),a("ul",[a("li",[s._v("Redis 的主从同步，分为全量同步和增量同步。")]),s._v(" "),a("li",[s._v("只有从机第一次连接上主机是全量同步")]),s._v(" "),a("li",[s._v("断线重连有可能触发全量同步也有可能是增量同步（master 判断 runid 是否一致）")]),s._v(" "),a("li",[s._v("除此之外的情况都是增量同步")])]),s._v(" "),a("h4",{attrs:{id:"全量同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全量同步"}},[s._v("#")]),s._v(" 全量同步")]),s._v(" "),a("p",[a("img",{attrs:{src:"/images/interview/redis-4.png",alt:""}}),a("br"),s._v("\nRedis 的全量同步过程主要分三个阶段：")]),s._v(" "),a("ul",[a("li",[s._v("同步快照阶段： Master 创建并发送快照给 Slave,Slave 载入并解析快照。 Master 同时\n将此阶段所产生的新的写命令存储到缓冲区。")]),s._v(" "),a("li",[s._v("同步写缓冲阶段： Master 向 Slave 同步存储在缓冲区的写操作命令。")]),s._v(" "),a("li",[s._v("同步增量阶段： Master 向 Slave 同步写操作命令。")])]),s._v(" "),a("h4",{attrs:{id:"增量同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增量同步"}},[s._v("#")]),s._v(" 增量同步")]),s._v(" "),a("p",[a("img",{attrs:{src:"/images/interview/redis-5.png",alt:""}}),a("br")]),s._v(" "),a("ul",[a("li",[s._v("Redis 增量同步主要指 Slave 完成初始化后开始正常工作时， Master 发生的写操作同步\n到 Slave 的过程。")]),s._v(" "),a("li",[s._v("通常情况下， Master 每执行一个写命令就会向 Slave 发送相同的写命令，然后 Slave 接收并执行。")])]),s._v(" "),a("h2",{attrs:{id:"sentinel-哨兵机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sentinel-哨兵机制"}},[s._v("#")]),s._v(" Sentinel 哨兵机制")]),s._v(" "),a("p",[s._v("Redis 主从复制的缺点：没有办法对 master 进行动态选举，需要使用 Sentinel 机制完成\n动态选举")]),s._v(" "),a("h3",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[s._v("#")]),s._v(" 简介")]),s._v(" "),a("ul",[a("li",[s._v("Sentinel(哨兵)进程是用于监控 redis 集群中 Master 主服务器工作的状态")]),s._v(" "),a("li",[s._v("在 Master 主服务器发生故障的时候，可以实现 Master 和 Slave 服务器的切换，保证系\n统的高可用（HA）")]),s._v(" "),a("li",[s._v("其已经被集成在 redis2.6+的版本中，Redis 的哨兵模式到了 2.8 版本之后就稳定了下来。")])]),s._v(" "),a("h3",{attrs:{id:"哨兵进程的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哨兵进程的作用"}},[s._v("#")]),s._v(" 哨兵进程的作用")]),s._v(" "),a("ul",[a("li",[a("ol",[a("li",[s._v("监控(Monitoring): 哨兵(sentinel) 会不断地检查你的 Master 和 Slave 是否运作正\n常。")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[s._v("提醒(Notification)： 当被监控的某个 Redis 节点出现问题时, 哨兵(sentinel) 可以通\n过 API 向管理员或者其他应用程序发送通知。")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[s._v("自动故障迁移(Automatic failover)：当一个 Master 不能正常工作时，哨兵(sentinel)\n会开始一次自动故障迁移操作。")])]),s._v(" "),a("ul",[a("li",[s._v("它会将失效 Master 的其中一个 Slave 升级为新的 Master, 并让失效 Master 的其他\nSlave 改为复制新的 Master；* 当客户端试图连接失效的 Master 时，集群也会向客户端返回新 Master 的地址，使\n得集群可以使用现在的 Master 替换失效 Master。")]),s._v(" "),a("li",[s._v("Master 和 Slave 服务器切换后， Master 的 redis.conf、 Slave 的 redis.conf 和\nsentinel.conf 的配置文件的内容都会发生相应的改变，即， Master 主服务器的\nredis.conf 配置文件中会多一行 slaveof 的配置， sentinel.conf 的监控目标会随之调\n换。")])])])]),s._v(" "),a("h4",{attrs:{id:"哨兵进程的工作方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哨兵进程的工作方式"}},[s._v("#")]),s._v(" 哨兵进程的工作方式")]),s._v(" "),a("ul",[a("li",[s._v("每个 Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的 Master 主服务器，\nSlave 从服务器以及其他 Sentinel（哨兵）进程发送一个 PING 命令。")]),s._v(" "),a("li",[s._v("如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 downafter-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为\n主观下线（SDOWN）。")]),s._v(" "),a("li",[s._v("如果一个 Master 主服务器被标记为主观下线（SDOWN），则正在监视这个 Master 主\n服务器的所有 Sentinel（哨兵） 进程要以每秒一次的频率确认 Master 主服务器的确\n进入了主观下线状态。")]),s._v(" "),a("li",[s._v("当有足够数量的 Sentinel（哨兵） 进程（大于等于配置文件指定的值）在指定的时间\n范围内确认 Master 主服务器进入了主观下线状态（SDOWN）， 则 Master 主服务器\n会被标记为客观下线（ODOWN）。")]),s._v(" "),a("li",[s._v("在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有\nMaster 主服务器、 Slave 从服务器发送 INFO 命令。")]),s._v(" "),a("li",[s._v("当 Master 主服务器被 Sentinel （哨兵）进程标记为客观下线（ODOWN） 时， Sentinel（哨兵）进程向下线的 Master 主服务器的所有 Slave 从服务器发送 INFO 命令的频\n率会从 10 秒一次改为每秒一次。")]),s._v(" "),a("li",[s._v("若没有足够数量的 Sentinel（哨兵）进程同意 Master 主服务器下线， Master 主服\n务器的客观下线状态就会被移除。若 Master 主服务器重新向 Sentinel（哨兵）进程\n发送 PING 命令返回有效回复， Master 主服务器的主观下线状态就会被移除。\n"),a("img",{attrs:{src:"/images/interview/redis-6.png",alt:""}}),a("br")])]),s._v(" "),a("h3",{attrs:{id:"案例演示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#案例演示"}},[s._v("#")]),s._v(" 案例演示")]),s._v(" "),a("ul",[a("li",[s._v("修改从机的 sentinel.conf")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("#sentinel monitor <master-name> <master ip> <master port>\n<quorum>\nsentinel monitor mymaster 192.168.10.133 6379 1\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("其他配置项说明")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('# Example sentinel.conf\n# 哨兵 sentinel 实例运行的端口 默认 26379\nport 26379\n\n# 哨兵 sentinel 的工作目录dir /tmp\n# 哨兵 sentinel 监控的 redis 主节点的 ip port\n# master-name 可以自己命名的主节点名字 只能由字母 A-z、数字 0-9 、这三个字符".-_"组成。\n# quorum 当这些 quorum 个数 sentinel 哨兵认为 master 主节点失联 那么这时 客观上认为主节点\n# 失联了\n# sentinel monitor <master-name> <ip> <redis-port> <quorum>\nsentinel monitor mymaster 127.0.0.1 6379 2\n\n# 当在 Redis 实例中开启了 requirepass foobared 授权密码 这样所有连接 Redis 实例的客户端都\n# 要提供密码\n# 设置哨兵 sentinel 连接主从的密码 注意必须为主从设置一样的验证密码\n# sentinel auth-pass <master-name> <password>\nsentinel auth-pass mymaster MySUPER--secret-0123passw0rd\n\n# 指定多少毫秒之后 主节点没有应答哨兵 sentinel 此时 哨兵主观上认为主节点下线 默认 30 秒\n# sentinel down-after-milliseconds <master-name> <milliseconds>\nsentinel down-after-milliseconds mymaster 30000\n# 这个配置项指定了在发生 failover 主备切换时最多可以有多少个 slave 同时对新的master进行同\n步，这个数字越小，完成 failover 所需的时间就越长，\n但是如果这个数字越大，就意味着越 多的 slave 因为 replication 而不可用。\n可以通过将这个值设为 1 来保证每次只有一个 slave 处于不能处理命令请求的状态。\n# sentinel parallel-syncs <master-name> <numslaves>\nsentinel parallel-syncs mymaster 1\n\n# 故障转移的超时时间 failover-timeout 可以用在以下这些方面：\n#1. 同一个 sentinel 对同一个 master 两次 failover 之间的间隔时间。\n#2. 当一个 slave 从一个错误的 master 那里同步数据开始计算时间。直到 slave 被纠正为向正确的\nmaster 那里同步数据时。\n#3.当想要取消一个正在进行的 failover 所需要的时间。\n#4.当进行 failover 时，配置所有 slaves 指向新的 master 所需的最大时间。不过，即使过了这个超\n时， slaves 依然会被正确配置为指向 master，但是就不按 parallel-syncs 所配置的规则来了\n# 默认三分钟\n# sentinel failover-timeout <master-name> <milliseconds>\nsentinel failover-timeout mymaster 180000\n\n# SCRIPTS EXECUTION\n#配置事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。\n#对于脚本的运行结果有以下规则：\n#若脚本执行后返回 1，那么该脚本稍后将会被再次执行，重复次数目前默认为 10\n#若脚本执行后返回 2，或者比 2 更高的一个返回值，脚本将不会重复执行。\n#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为 1 时的行为相同。\n#一个脚本的最大执行时间为 60s，如果超过这个时间，脚本将会被一个 SIGKILL 信号终止，之后重新\n执行。\n#通知型脚本:当 sentinel 有任何警告级别的事件发生时（比如说 redis 实例的主观失效和客观失效等\n等），将会去调用这个脚本，\n这时这个脚本应该通过邮件， SMS 等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本\n时，将传给脚本两个参数，\n一个是事件的类型，\n一个是事件的描述。\n如果 sentinel.conf 配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是\n可执行的，否则 sentinel 无法正常启动成功。\n#通知脚本\n# sentinel notification-script <master-name> <script-path>\nsentinel notification-script mymaster /var/redis/notify.sh\n\n# 客户端重新配置主节点参数脚本\n# 当一个 master 由于 failover 而发生改变时，这个脚本将会被调用，通知相关的客户端关于 master\n地址已经发生改变的信息。\n# 以下参数将会在调用脚本时传给脚本:\n# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>\n# 目前<state>总是“failover” ,\n# <role>是“leader”或者“observer”中的一个。\n# 参数 from-ip, from-port, to-ip, to-port 是用来和旧的 master 和新的 master(即旧的 slave)通\n信的\n# 这个脚本应该是通用的，能被多次调用，不是针对性的。\n# sentinel client-reconfig-script <master-name> <script-path>\nsentinel client-reconfig-script mymaster /var/redis/reconfig.sh\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br"),a("span",{staticClass:"line-number"},[s._v("49")]),a("br"),a("span",{staticClass:"line-number"},[s._v("50")]),a("br"),a("span",{staticClass:"line-number"},[s._v("51")]),a("br"),a("span",{staticClass:"line-number"},[s._v("52")]),a("br"),a("span",{staticClass:"line-number"},[s._v("53")]),a("br"),a("span",{staticClass:"line-number"},[s._v("54")]),a("br"),a("span",{staticClass:"line-number"},[s._v("55")]),a("br"),a("span",{staticClass:"line-number"},[s._v("56")]),a("br"),a("span",{staticClass:"line-number"},[s._v("57")]),a("br"),a("span",{staticClass:"line-number"},[s._v("58")]),a("br"),a("span",{staticClass:"line-number"},[s._v("59")]),a("br"),a("span",{staticClass:"line-number"},[s._v("60")]),a("br"),a("span",{staticClass:"line-number"},[s._v("61")]),a("br"),a("span",{staticClass:"line-number"},[s._v("62")]),a("br"),a("span",{staticClass:"line-number"},[s._v("63")]),a("br"),a("span",{staticClass:"line-number"},[s._v("64")]),a("br"),a("span",{staticClass:"line-number"},[s._v("65")]),a("br"),a("span",{staticClass:"line-number"},[s._v("66")]),a("br"),a("span",{staticClass:"line-number"},[s._v("67")]),a("br"),a("span",{staticClass:"line-number"},[s._v("68")]),a("br"),a("span",{staticClass:"line-number"},[s._v("69")]),a("br"),a("span",{staticClass:"line-number"},[s._v("70")]),a("br"),a("span",{staticClass:"line-number"},[s._v("71")]),a("br")])]),a("ul",[a("li",[s._v("通过 redis-sentinel 启动哨兵服务")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("./redis-sentinel sentinel.conf\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h2",{attrs:{id:"cluster集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cluster集群"}},[s._v("#")]),s._v(" Cluster集群")]),s._v(" "),a("p",[s._v("redis3.0 以后推出的 redis cluster 集群方案， redis cluster 集群保证了高可用、 高性能、\n高可扩展性。")]),s._v(" "),a("h3",{attrs:{id:"redis-cluster架构图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster架构图"}},[s._v("#")]),s._v(" redis-cluster架构图")]),s._v(" "),a("p",[a("img",{attrs:{src:"/images/interview/redis-7.png",alt:""}}),a("br"),s._v("\n架构细节:")]),s._v(" "),a("ul",[a("li",[s._v("(1)所有的 redis 节点彼此互联(PING-PONG 机制),内部使用二进制协议优化传输速度和带\n宽.")]),s._v(" "),a("li",[s._v("(2)节点的 fail 是通过集群中超过半数的节点检测失效时才生效.")]),s._v(" "),a("li",[s._v("(3)客户端与 redis 节点直连,不需要中间 proxy 层.客户端不需要连接集群所有节点,连接集\n群中任何一个可用节点即可")]),s._v(" "),a("li",[s._v("(4)redis-cluster 把所有的物理节点映射到[0-16383]slot 上,cluster 负责维护\nnode<->slot<->value\nRedis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value\n时， redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这\n样每个 key 都会对应一个编号在 0-16383 之间的哈希槽， redis 会根据节点数量大致均\n等的将哈希槽映射到不同的节点\n"),a("img",{attrs:{src:"/images/interview/redis-8.png",alt:""}}),a("br")])]),s._v(" "),a("h3",{attrs:{id:"redis-cluster-投票-容错"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster-投票-容错"}},[s._v("#")]),s._v(" redis-cluster 投票：容错")]),s._v(" "),a("p",[s._v("最小节点数： 3 台")]),s._v(" "),a("ul",[a("li",[s._v("节点失效判断： 集群中所有 master 参与投票,如果半数以上 master 节点与其中一\n个 master 节点通信超过(cluster-node-timeout),认为该 master 节点挂掉.")]),s._v(" "),a("li",[s._v("集群失效判断:什么时候整个集群不可用(cluster_state:fail)?\n"),a("ul",[a("li",[s._v("如果集群任意 master 挂掉,且当前 master 没有 slave，则集群进入 fail 状态。也可以\n理解成集群的[0-16383]slot 映射不完全时进入 fail 状态。")]),s._v(" "),a("li",[s._v("如果集群超过半数以上 master 挂掉，无论是否有 slave，集群进入 fail 状态。")])])])]),s._v(" "),a("h3",{attrs:{id:"安装-ruby-环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装-ruby-环境"}},[s._v("#")]),s._v(" 安装 Ruby 环境")]),s._v(" "),a("p",[s._v("redis 集群需要使用集群管理脚本 redis-trib.rb，它的执行相应依赖 ruby 环境。")]),s._v(" "),a("ul",[a("li",[s._v("第一步：安装 ruby")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("yum install ruby\nyum install rubygems\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("第二步：安装 ruby 和 redis 的接口程序 redis-3.2.2.gem")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("gem install redis -V 3.2.2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("ul",[a("li",[s._v("第三步： 复制 redis-3.2.9/src/redis-trib.rb 文件到/usr/local/redis 目录")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("cp redis-3.2.9/src/redis-trib.rb /usr/local/redis-cluster/ -r\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h3",{attrs:{id:"安装-redis-集群-rediscluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装-redis-集群-rediscluster"}},[s._v("#")]),s._v(" 安装 Redis 集群（RedisCluster）")]),s._v(" "),a("p",[s._v("Redis 集群最少需要三台主服务器，三台从服务器。\n端口号分别为： 7001~7006")]),s._v(" "),a("ul",[a("li",[s._v("第一步：创建 7001 实例，并编辑 redis.conf 文件，修改 port 为 7001。\n注意：创建实例，即拷贝单机版安装时，生成的 bin 目录，为 7001 目录。")]),s._v(" "),a("li",[s._v("第二步：修改 redis.conf 配置文件，打开 Cluster-enable yes")]),s._v(" "),a("li",[s._v("第三步：复制 7001，创建 7002~7006 实例， 注意端口修改。")]),s._v(" "),a("li",[s._v("第四步：启动所有的实例")]),s._v(" "),a("li",[s._v("第五步：创建 Redis 集群")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("./redis-trib.rb create --replicas 1 192.168.10.133:7001\n192.168.10.133:7002 192.168.10.133:7003 192.168.10.133:7004\n192.168.10.133:7005 192.168.10.133:7006\n>>> Creating cluster\nConnecting to node 192.168.10.133:7001: OK\nConnecting to node 192.168.10.133:7002: OK\nConnecting to node 192.168.10.133:7003: OK\nConnecting to node 192.168.10.133:7004: OK\nConnecting to node 192.168.10.133:7005: OK\nConnecting to node 192.168.10.133:7006: OK\n>>> Performing hash slots allocation on 6 nodes...\nUsing 3 masters:\n192.168.10.133:7001\n192.168.10.133:7002\n192.168.10.133:7003\n\nAdding replica 192.168.10.133:7004 to 192.168.10.133:7001\nAdding replica 192.168.10.133:7005 to 192.168.10.133:7002\nAdding replica 192.168.10.133:7006 to 192.168.10.133:7003\nM: d8f6a0e3192c905f0aad411946f3ef9305350420 192.168.10.133:7001\nslots:0-5460 (5461 slots) master\nM: 7a12bc730ddc939c84a156f276c446c28acf798c 192.168.10.133:7002\nslots:5461-10922 (5462 slots) master\nM: 93f73d2424a796657948c660928b71edd3db881f 192.168.10.133:7003\nslots:10923-16383 (5461 slots) master\nS: f79802d3da6b58ef6f9f30c903db7b2f79664e61 192.168.10.133:7004\nreplicates d8f6a0e3192c905f0aad411946f3ef9305350420\nS: 0bc78702413eb88eb6d7982833a6e040c6af05be 192.168.10.133:7005\nreplicates 7a12bc730ddc939c84a156f276c446c28acf798c\nS: 4170a68ba6b7757e914056e2857bb84c5e10950e 192.168.10.133:7006\nreplicates 93f73d2424a796657948c660928b71edd3db881f\nCan I set the above configuration? (type 'yes' to accept): yes\n>>> Nodes configuration updated\n>>> Assign a different config epoch to each node\n>>> Sending CLUSTER MEET messages to join the cluster\nWaiting for the cluster to join....\n>>> Performing Cluster Check (using node 192.168.10.133:7001)\nM: d8f6a0e3192c905f0aad411946f3ef9305350420 192.168.10.133:7001\nslots:0-5460 (5461 slots) master\nM: 7a12bc730ddc939c84a156f276c446c28acf798c 192.168.10.133:7002\nslots:5461-10922 (5462 slots) master\nM: 93f73d2424a796657948c660928b71edd3db881f 192.168.10.133:7003\nslots:10923-16383 (5461 slots) master\nM: f79802d3da6b58ef6f9f30c903db7b2f79664e61 192.168.10.133:7004\nslots: (0 slots) master\nreplicates d8f6a0e3192c905f0aad411946f3ef9305350420\nM: 0bc78702413eb88eb6d7982833a6e040c6af05be 192.168.10.133:7005\nslots: (0 slots) master\nreplicates 7a12bc730ddc939c84a156f276c446c28acf798c\nM: 4170a68ba6b7757e914056e2857bb84c5e10950e 192.168.10.133:7006\nslots: (0 slots) master\nreplicates 93f73d2424a796657948c660928b71edd3db881f\n[OK] All nodes agree about slots configuration.\n>>> Check for open slots...\n>>> Check slots coverage...\n[OK] All 16384 slots covered.\n[root@localhost-0723 redis]#\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br"),a("span",{staticClass:"line-number"},[s._v("49")]),a("br"),a("span",{staticClass:"line-number"},[s._v("50")]),a("br"),a("span",{staticClass:"line-number"},[s._v("51")]),a("br"),a("span",{staticClass:"line-number"},[s._v("52")]),a("br"),a("span",{staticClass:"line-number"},[s._v("53")]),a("br"),a("span",{staticClass:"line-number"},[s._v("54")]),a("br"),a("span",{staticClass:"line-number"},[s._v("55")]),a("br"),a("span",{staticClass:"line-number"},[s._v("56")]),a("br"),a("span",{staticClass:"line-number"},[s._v("57")]),a("br")])]),a("h3",{attrs:{id:"命令客户端连接集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命令客户端连接集群"}},[s._v("#")]),s._v(" 命令客户端连接集群")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# 命令： ./redis-cli –h 127.0.0.1 –p 7001 –c\n# 注意： -c 表示是以 redis 集群方式进行连接\n./redis-cli -p 7006 -c\n127.0.0.1:7006> set key1 123\n-> Redirected to slot [9189] located at 127.0.0.1:7002\nOK\n127.0.0.1:7002>\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("h3",{attrs:{id:"查看集群的命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看集群的命令"}},[s._v("#")]),s._v(" 查看集群的命令")]),s._v(" "),a("ul",[a("li",[s._v("查看集群状态")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("127.0.0.1:7003> cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:6\ncluster_size:3\ncluster_current_epoch:6\ncluster_my_epoch:3\ncluster_stats_messages_sent:926\ncluster_stats_messages_received:926\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("ul",[a("li",[s._v("查看集群中的节点")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("127.0.0.1:7003> cluster nodes\n7a12bc730ddc939c84a156f276c446c28acf798c 127.0.0.1:7002 master - 0 1443601739754 2\nconnected 5461-10922\n93f73d2424a796657948c660928b71edd3db881f 127.0.0.1:7003 myself,master - 0 0 3\nconnected 10923-16383\nd8f6a0e3192c905f0aad411946f3ef9305350420 127.0.0.1:7001 master - 0 1443601741267 1\nconnected 0-5460\n4170a68ba6b7757e914056e2857bb84c5e10950e 127.0.0.1:7006 slave\n93f73d2424a796657948c660928b71edd3db881f 0 1443601739250 6 connected\nf79802d3da6b58ef6f9f30c903db7b2f79664e61 127.0.0.1:7004 slave\nd8f6a0e3192c905f0aad411946f3ef9305350420 0 1443601742277 4 connected\n0bc78702413eb88eb6d7982833a6e040c6af05be 127.0.0.1:7005 slave\n7a12bc730ddc939c84a156f276c446c28acf798c 0 1443601740259 5 connected\n127.0.0.1:7003>\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("h3",{attrs:{id:"维护节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#维护节点"}},[s._v("#")]),s._v(" 维护节点")]),s._v(" "),a("p",[s._v("集群创建成功后可以继续向集群中添加节点")]),s._v(" "),a("h4",{attrs:{id:"添加主节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#添加主节点"}},[s._v("#")]),s._v(" 添加主节点")]),s._v(" "),a("ul",[a("li",[s._v("先创建 7007 节点")]),s._v(" "),a("li",[s._v("添加 7007 结点作为新节点")]),s._v(" "),a("li",[s._v("执行命令： ./redis-trib.rb add-node 127.0.0.1:7007 127.0.0.1:7001")]),s._v(" "),a("li",[s._v("查看集群节点： cluster nodes")])]),s._v(" "),a("h4",{attrs:{id:"hash槽重新分配-数据迁移"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash槽重新分配-数据迁移"}},[s._v("#")]),s._v(" hash槽重新分配(数据迁移)")]),s._v(" "),a("p",[s._v("添加完主节点需要对主节点进行 hash 槽分配，这样该主节才可以存储数据。")]),s._v(" "),a("ul",[a("li",[s._v("查看集群中槽占用情况\n"),a("ul",[a("li",[s._v("redis 集群有 16384 个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占\n用情况")])])]),s._v(" "),a("li",[s._v("给刚添加的 7007 结点分配槽\n"),a("ul",[a("li",[s._v("第一步：连接上集群（连接集群中任意一个可用结点都行）"),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("./redis-trib.rb reshard 192.168.10.133:7001\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])])]),s._v(" "),a("li",[s._v("第二步：输入要分配的槽数量\n"),a("img",{attrs:{src:"/images/interview/redis-9.png",alt:""}}),a("br")]),s._v(" "),a("li",[s._v("第三步：输入接收槽的结点 id\n"),a("img",{attrs:{src:"/images/interview/redis-10.png",alt:""}}),a("br")]),s._v(" "),a("li",[s._v("第四步：输入源结点 id\n"),a("img",{attrs:{src:"/images/interview/redis-11.png",alt:""}}),a("br")]),s._v(" "),a("li",[s._v("第五步：输入 yes 开始移动槽到目标结点 id\n"),a("img",{attrs:{src:"/images/interview/redis-12.png",alt:""}}),a("br")])])])]),s._v(" "),a("h4",{attrs:{id:"添加从节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#添加从节点"}},[s._v("#")]),s._v(" 添加从节点")]),s._v(" "),a("p",[s._v("添加 7008 从结点，将 7008 作为 7007 的从结点")]),s._v(" "),a("ul",[a("li",[s._v("命令： ./redis-trib.rb add-node --slave --master-id 主节\n点 id 新节点的 ip 和端口 旧节点 ip 和端口（集群中任一节点\n都可以）"),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("./redis-trib.rb add-node --slave --master-id\n35da64607a02c9159334a19164e68dd95a3b943c\n192.168.10.103:7008 192.168.10.103:7001\n\n# 35da64607a02c9159334a19164e68dd95a3b943c 是 7007 结点的 id，可通\n  过 cluster nodes 查看。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[s._v("WARNING")]),s._v(" "),a("p",[s._v("注意：如果原来该结点在集群中的配置信息已经生成到 cluster-config-file 指定的配置文件\n中（如果 cluster-config-file 没有指定则默认为 nodes.conf），这时可能会报错："),a("br"),s._v("\n[ERR] Node XXXXXX is not empty. Either the node already knows other nodes\n(check with CLUSTER NODES) or contains some key in database 0"),a("br"),s._v("\n解决方法是删除生成的配置文件 nodes.conf，删除后再执行./redis-trib.rb add-node 指令")])])]),s._v(" "),a("li",[s._v("查看集群中的结点，刚添加的 7008 为 7007 的从节点：  cluster nodes")])]),s._v(" "),a("h4",{attrs:{id:"删除从节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除从节点"}},[s._v("#")]),s._v(" 删除从节点")]),s._v(" "),a("ul",[a("li",[s._v("命 令 ： ./redis-trib.rb del-node 127.0.0.1:7005\n4b45eb75c8b428fbd77ab979b85080146a9bc017")]),s._v(" "),a("li",[s._v("删除已经占有 hash 槽的结点会失败，报错如下："),a("br"),s._v("\n[ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again."),a("br"),s._v("\n需要将该结点占用的 hash 槽分配出去（参考 hash 槽重新分配章节）。")])]),s._v(" "),a("h4",{attrs:{id:"jedis-连接集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jedis-连接集群"}},[s._v("#")]),s._v(" jedis 连接集群")]),s._v(" "),a("p",[s._v("service iptables stop")])])}),[],!1,null,null,null);e.default=t.exports}}]);