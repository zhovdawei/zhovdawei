(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{422:function(a,v,i){"use strict";i.r(v);var l=i(42),_=Object(l.a)({},(function(){var a=this,v=a.$createElement,i=a._self._c||v;return i("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[i("h1",{attrs:{id:"java虚拟机知识"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机知识"}},[a._v("#")]),a._v(" Java虚拟机知识")]),a._v(" "),i("hr"),a._v(" "),i("h2",{attrs:{id:"运行时数据区域"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区域"}},[a._v("#")]),a._v(" 运行时数据区域")]),a._v(" "),i("p",[i("img",{attrs:{src:"/images/interview/iw-6.png",alt:""}}),i("br")]),a._v(" "),i("h3",{attrs:{id:"程序计数器"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),i("p",[a._v("程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码行号指示器，程序控制流指示器。\n分支，循环，跳转，异常处理，线程恢复等基础功能都依赖程序计数器来完成。")]),a._v(" "),i("ul",[i("li",[a._v("线程私有，线程隔离")]),a._v(" "),i("li",[a._v("执行Java方法，程序计数器记录的是虚拟机字节码指令的地址")]),a._v(" "),i("li",[a._v("执行Native方法，程序计数器值为空")]),a._v(" "),i("li",[a._v("程序计数器是唯一一个在《java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域")])]),a._v(" "),i("h3",{attrs:{id:"虚拟机栈"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[a._v("#")]),a._v(" 虚拟机栈")]),a._v(" "),i("p",[a._v("虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、\n操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。")]),a._v(" "),i("ul",[i("li",[a._v("线程私有")]),a._v(" "),i("li",[a._v("局部变量表\n"),i("ul",[i("li",[a._v("局部表量表的数据类型如下\n"),i("ul",[i("li",[a._v("基本数据类型(boolean,byte,char,short,int,float,long,double)")]),a._v(" "),i("li",[a._v("对象引用(reference):指向对象起始地址的引用指针，或指向一个代表对象的句柄，或其他与此对象相关的位置")]),a._v(" "),i("li",[a._v("returnAddress 一条字节码指令的地址")])])]),a._v(" "),i("li",[a._v("这些数据类型在局部变量表中以局部变量槽来表示，除了long，double占用两个变量槽，其他都只占用一个")]),a._v(" "),i("li",[a._v("局部变量表所需的内存空间在编译阶段完成分配，进入一个方法，这个方法所需要的的变量槽数量是确定的")]),a._v(" "),i("li",[a._v("注意：一个方法所需要的局部变量槽是确定，而一个槽在32位/64位操作系统下占用的物理内存是不确定的")])])]),a._v(" "),i("li",[a._v("异常分类\n"),i("ul",[i("li",[a._v("StackOverflowError : 线程请求的栈深度大于虚拟机设定的站深度时出现")]),a._v(" "),i("li",[a._v("OutOfMemoryError : 栈扩展时无法申请到足够的内存(注意：hotspot虚拟机不允许栈容量动态扩展，所以这个OOM在HotSpot\n虚拟机中，只出现在虚拟机启动时请求栈容量分配不足时出现)")])])])]),a._v(" "),i("h3",{attrs:{id:"本地方法栈"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),i("p",[a._v("本地方法栈为Native执行服务，其他行为与虚拟机栈类似。")]),a._v(" "),i("ul",[i("li",[a._v("线程私有")]),a._v(" "),i("li",[a._v("异常分类\n"),i("ul",[i("li",[a._v("StackOverflowError")]),a._v(" "),i("li",[a._v("OutOfMemoryError")])])])]),a._v(" "),i("h3",{attrs:{id:"堆"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),i("p",[a._v("Java堆(Heap)是虚拟机管理的内存中最大的一块。Java世界里“几乎”所有的对象实例都在这里分配内存。(猜测：可能出现的值类型，\n目前的即时编译，逃逸分析，栈上分配，标量替换等技术，使得全部Java实例都分配在堆上不在绝对)")]),a._v(" "),i("ul",[i("li",[a._v("线程共享")]),a._v(" "),i("li",[a._v("Java堆是垃圾收集器管理的区域\n"),i("ul",[i("li",[a._v("经典分代垃圾收集区域划分：\n新生代，老年代，永久代，Eden，FromSurvivor，ToSurvivor")]),a._v(" "),i("li",[a._v("G1垃圾收集区域")])])]),a._v(" "),i("li",[a._v("Java堆可以固定大小，也可扩展( -Xmx -Xms)")]),a._v(" "),i("li",[a._v("outOfMemortError 内存无法分配空间，堆无法扩展")])]),a._v(" "),i("h3",{attrs:{id:"方法区"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),i("p",[a._v("用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等数据。又名“非堆”，区别于Java堆。")]),a._v(" "),i("ul",[i("li",[a._v("线程共享")]),a._v(" "),i("li",[a._v("永久代：\n"),i("ul",[i("li",[a._v("JDK8以前：垃圾收集器分代设计扩展到方法区，或者说使用永久代实现了方法区，这样方法区也被垃圾收集器接管。从而导致了一个问题：\n更容易内存溢出。永久代上限调整： -XX:MaxPermSize")]),a._v(" "),i("li",[a._v("JDK7: 永久代里的字符串常量，静态变量等移出")]),a._v(" "),i("li",[a._v("JDK8彻底废弃了永久代，用本地内存元空间代替。")])])]),a._v(" "),i("li",[a._v("方法区垃圾回收行为比较少出现，回收效果难以令人满意。\n"),i("ul",[i("li",[a._v("常量池的回收")]),a._v(" "),i("li",[a._v("类型的卸载")])])]),a._v(" "),i("li",[a._v("方法区无法满足新的内存分配需求时，抛出OutOfMemoryError")])]),a._v(" "),i("h3",{attrs:{id:"运行时常量池"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池"}},[a._v("#")]),a._v(" 运行时常量池")]),a._v(" "),i("p",[a._v("运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等面熟信息外，还有一项信息是常量池表，用于存放编译期\n生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。除了保存class文件中描述的符号引用\n外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。")]),a._v(" "),i("ul",[i("li",[a._v("动态性：并不要求常量只有在编译期才能产生，也就是说并非预置入class文件的常量池能进入方法区的运行时常量池，运行期间产生\n的常量也能进入。例如：string.intern()方法")]),a._v(" "),i("li",[a._v("受方法区内存限制：OutOfMemoryError")])]),a._v(" "),i("h3",{attrs:{id:"直接内存"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#直接内存"}},[a._v("#")]),a._v(" 直接内存")]),a._v(" "),i("p",[a._v("直接内存并不是虚拟机运行时数据区的一部分，不在《Java虚拟机规范》的定义中。这部分内存的频繁使用也是可能出现OOM的。")]),a._v(" "),i("ul",[i("li",[a._v("JDK1.4加入的NIO，引入了Channel与Buffer的I/O方式，可以使用native方法库，分配堆外内存，通过DirectByteBuffer\n对象对这块内存进行引用操作。")]),a._v(" "),i("li",[a._v("当我们分配虚拟机内存，或者动态扩展内存时，如果忘记直接内存大小，可能发生内存上限不足的问题，也就是抛出OOM。")])]),a._v(" "),i("h2",{attrs:{id:"垃圾收集器"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[a._v("#")]),a._v(" 垃圾收集器")]),a._v(" "),i("h3",{attrs:{id:"概述"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),i("ul",[i("li",[a._v("程序计数器，虚拟机栈，本地方法栈随线程而生，随线程而死")]),a._v(" "),i("li",[a._v("需要回收的是堆和方法区")]),a._v(" "),i("li",[a._v("垃圾回收行为，是内存自动化管理的产物")]),a._v(" "),i("li",[a._v("Hotspot虚拟机提供了垃圾回收的功能")])]),a._v(" "),i("h3",{attrs:{id:"对象死亡判断"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#对象死亡判断"}},[a._v("#")]),a._v(" 对象死亡判断")]),a._v(" "),i("ul",[i("li",[i("p",[i("strong",[a._v("引用计数法")])]),a._v(" "),i("ul",[i("li",[a._v("描述： 在对象里面增加一个引用计数器，引用一次就加1，判断引用计数器值正负可以判断是否存在引用")]),a._v(" "),i("li",[a._v("Java领域主流的Java虚拟机都没有选用引用计数器来鉴别对象是否可回收")]),a._v(" "),i("li",[a._v("缺点：很难解决循环引用的问题")])])]),a._v(" "),i("li",[i("p",[i("strong",[a._v("可达性分析算法")])]),a._v(" "),i("ul",[i("li",[a._v('描述：通过一系列称为"GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的\n路径称为"引用链"，如果某个对象到到GC Roots间没有任何引用链相连，或者用图论的话来说，就是从GC roots到这个对象不可达时，则证明\n此对象不可能再被使用。')]),a._v(" "),i("li",[a._v("GC Roots :\n"),i("ul",[i("li",[a._v("在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到参数，局部变量，临时变量")]),a._v(" "),i("li",[a._v("在方法区中静态属性引用的对象，譬如Java类的引用类型静态变量")]),a._v(" "),i("li",[a._v("在方法区中常量引用的对象，譬如字符串常量池里的引用")]),a._v(" "),i("li",[a._v("在本地方法栈中JNI(通常所说的Native方法)引用的对象")]),a._v(" "),i("li",[a._v("Java虚拟机内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象(比如NullPointException,OutOfMemoryError)\n等，还有系统类加载器")]),a._v(" "),i("li",[a._v("所有被同步锁(synchronized关键字)持有的对象")]),a._v(" "),i("li",[a._v("反应Java虚拟机内部情况的JMXBean,JVMTI中注册的回调、本地代码缓存等")])])])])]),a._v(" "),i("li",[i("p",[i("strong",[a._v("再谈引用")])]),a._v(" "),i("ul",[i("li",[i("strong",[a._v("强引用 Strongly Reference")]),i("br"),a._v('\n强引用是最传统的"引用"的定义，是指在程序代码之中普遍存在的引用赋值，即类似"Object obj = new Object()"\n这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。')]),a._v(" "),i("li",[i("strong",[a._v("软引用 Soft Reference")]),i("br"),a._v("\n软引用是用来描述一些还有，但非必须的对象。只被软应用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象\n列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2版之后提供了\nSoftReference类来实现软引用。")]),a._v(" "),i("li",[i("strong",[a._v("弱引用 Weak Reference")]),i("br"),a._v("\n弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器\n开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2版之后提供了WeakReference类来实现弱引用。")]),a._v(" "),i("li",[i("strong",[a._v("虚引用 Phantom Reference")]),i("br"),a._v('\n虚引用也称为"幽灵引用"或者"幻影引用"，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，\n也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个\n系统通知。在JDK1.2版之后提供PhantomReference类来实现虚引用。')])])]),a._v(" "),i("li",[i("p",[a._v("生与死")]),a._v(" "),i("ul",[i("li",[a._v("即使被可达性分析算法判断为不可达对象，也不是立即就被回收，而是一个缓刑的状态。真正判定一个对象死亡需要两次标记过程。")]),a._v(" "),i("li",[a._v("可达性分析判断不可达的对象，第一次被标记，随后进行一次筛选，条件是该对象是否有必要执行finalize()方法。\n"),i("ul",[i("li",[a._v("如果对象没有覆盖finalize()方法，判定为不必执行这个方法，即对象将被回收")]),a._v(" "),i("li",[a._v("如果该对象已经执行过finalize()方法，判定为不必执行这个方法，即对象将被回收")])])]),a._v(" "),i("li",[a._v("判定有必要执行的对象，将进入F-Queue队列中，由虚拟机自动创建的低优先级的Finalizer线程去执行对象的finalize()方法，\n但不保证一定执行完整个方法。收集器将对F-Queue中的对象进行第二次标记。\n"),i("ul",[i("li",[a._v("如果在finalize()方法中，对象将自己与引用链建立连接，就可以逃过这次回收。")]),a._v(" "),i("li",[a._v("如果在finalize()方法中，对象没有建立任何连接，该对象将被回收。")])])]),a._v(" "),i("li",[a._v("不建议使用该方法，如果需要关闭外部资源连接，可以在try-finally里面做的很好")])])]),a._v(" "),i("li",[i("p",[a._v("方法区的回收")]),a._v(" "),i("ul",[i("li",[a._v("方法区由于严苛的判定条件，致使回收价值很低。")]),a._v(" "),i("li",[a._v("回收内容： 废弃的常量和不再使用的类型")]),a._v(" "),i("li",[a._v("常量判定：一个字符串常量“Java”,如果当前系统没有任何一个字符串对象的值是“Java”,虚拟机就会判定该常量可回收。")]),a._v(" "),i("li",[a._v("不可用类判定：Java虚拟机允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而不是和对象一样，没有\n引用就必然会回收。关于是否要对类型进行回收，虚拟机提供-Xnoclassgc参数控制。还可以使用-verbose:class,以及\n-XX:+TraceClassLoading，-XX:+TraceClassUnloading查看类加载和卸载信息\n"),i("ul",[i("li",[a._v("该类的所有实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例")]),a._v(" "),i("li",[a._v("加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGI,JSP的重加载，否则\n通常是很难达成的。")]),a._v(" "),i("li",[a._v("该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法")])])])])])]),a._v(" "),i("h3",{attrs:{id:"垃圾回收算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[a._v("#")]),a._v(" 垃圾回收算法")]),a._v(" "),i("ul",[i("li",[i("p",[a._v("一些术语")]),a._v(" "),i("ul",[i("li",[a._v("部分收集 Partial GC\n"),i("ul",[i("li",[a._v("新生代收集 Minor GC / Young GC")]),a._v(" "),i("li",[a._v("老年代收集 Major GC / Old GC")]),a._v(" "),i("li",[a._v("混合收集 Mixed GC")])])]),a._v(" "),i("li",[a._v("整堆收集 Full GC")])])]),a._v(" "),i("li",[i("p",[a._v("标记-清除算法")])]),a._v(" "),i("li",[i("p",[a._v("标记-复制算法")])]),a._v(" "),i("li",[i("p",[a._v("标记-整理算法")])])]),a._v(" "),i("h3",{attrs:{id:"hotspot算法细节"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#hotspot算法细节"}},[a._v("#")]),a._v(" HotSpot算法细节")]),a._v(" "),i("ul",[i("li",[i("p",[a._v("根节点枚举 "),i("br"),a._v("\n使用一组OopMap数据结构，一旦类加载动作完成，hotspot就回吧对象内什么偏移量上是什么类型的数据计算出来，在及时编译的过程中，也会\n在特定的位置记录下栈里和寄存器里哪些位置是引用。收集器在扫描时直接可以得知这些信息，不再需要一个不漏的从方法区等GC roots开始查找")])]),a._v(" "),i("li",[i("p",[a._v("安全点 "),i("br"),a._v("\nHotSpot没有为每条指令都生成OopMap,只在“特定位置”记录这些信息。这个“特定位置”就是安全点。安全点位置的选取基本上是以“是否具有让程序长\n时间执行的特征“为标准进行选定的。“长时间执行”的最明显特征就是指令序列的复用，例如方法调用，循环跳转，异常跳转等都属于指令复用，具有\n这些功能的指令才会昌盛安全点。")]),a._v(" "),i("ul",[i("li",[a._v("抢先式中断 "),i("br"),a._v("\n不需要线程的执行代码主动配合，垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点，就恢复这个线程\n，让其继续执行到安全点在中断。几乎没有户你及实现采用抢先式中断。")]),a._v(" "),i("li",[a._v("主动式中断 "),i("br"),a._v("\n当垃圾收集时，设置一个标志位，各个线程主动去轮询这个标志位，一旦发现标志位为真，线程自己会在执行到最近的安全点上，主动中断线程挂起。\nhotspot使用内存保护陷进方式实现，指令test.")])])]),a._v(" "),i("li",[i("p",[a._v("安全区域 "),i("br"),a._v("\n程序不执行即没有分配处理器时间，典型的场景便是用户线程处于Sleep或者Blocked状态，线程无法响应垃圾收集的中断请求，自然也不会走到安全点。\n这种情况就引入安全区域的问题，安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化。在这个区域个任何地方开始垃圾收集都是安全的。\n当用户执行到安全区域时，会标识自己进入安全区域，在这段时间里虚拟机就不必去管理已申明在安全区域的线程。当线程离开安全区域时，需要检查\n虚拟机是否已经完成根节点枚举。如果完成了，就当没事发生。否则就必须一直等待，直到收到可以离开安全区域的信息。")])]),a._v(" "),i("li",[i("p",[a._v("记忆集与卡集 "),i("br"),a._v("\n为了解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集的数据结构，用来避免吧整个老年代加紧GC Roots扫描范围。\n记忆集是一种用于记录从非手机区域指向手机区域的指针集合的抽象数据结构。最简单的实现可以使用非手机区域中所有跨代引用的对象数组来实现。")]),a._v(" "),i("ul",[i("li",[a._v("卡表，目前最常用的一种记忆集实现形式。")])])]),a._v(" "),i("li",[i("p",[a._v("写屏障 "),i("br"),a._v("\n有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。\n在Hotspot虚拟机里通过写屏障技术维护卡表状态。写屏障可以看作在虚拟机层面对引用类型字段赋值这个动作的AOP切面，在引用对象赋值时会产生\n一个环形通知。写前屏障，写后屏障。应用写屏障后，虚拟机就会为所有赋值操作生成响应的指令。")]),a._v(" "),i("ul",[i("li",[a._v("伪共享 ： -XX:+UseCondCardMark 开启卡表更新的条件判断")])])]),a._v(" "),i("li",[i("p",[a._v("并发的可达性分析 "),i("br")]),a._v(" "),i("ul",[i("li",[a._v("产生两种问题，把原本消亡的对象标记为存活，下次垃圾回收即可。把原本存活的对象标记为消亡，这个错误很严重。")]),a._v(" "),i("li",[a._v("产生上面问题的两个必要条件：\n"),i("ul",[i("li",[a._v("赋值器插入了一条或多条从黑色对象到白色对象的新引用")]),a._v(" "),i("li",[a._v("赋值器删除了全部灰色对象到该白色对象的新引用")])])]),a._v(" "),i("li",[a._v("解决方案：\n"),i("ul",[i("li",[a._v("增量更新(破坏第一个条件) "),i("br"),a._v("\n当黑色对象插入新的指向白色对象的引用关系时，将这个新插入记录下来，等并发扫描结束。再从这个新插入的黑色节点开始增量扫描")]),a._v(" "),i("li",[a._v("原始快照(破坏第二个条件) "),i("br"),a._v("\n当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，再从这个灰色节点开开始重新扫描一次。")]),a._v(" "),i("li",[a._v("CMS基于增量更新，G1基于原始快照")])])])])])]),a._v(" "),i("h3",{attrs:{id:"经典垃圾收集器"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#经典垃圾收集器"}},[a._v("#")]),a._v(" 经典垃圾收集器")]),a._v(" "),i("p",[i("img",{attrs:{src:"/images/interview/iw-22.png",alt:""}}),i("br")]),a._v(" "),i("ul",[i("li",[i("p",[a._v("Serial 收集器")]),a._v(" "),i("ul",[i("li",[a._v("默认新生代收集器")]),a._v(" "),i("li",[a._v("标记-复制算法")]),a._v(" "),i("li",[a._v("单线程")]),a._v(" "),i("li",[a._v("额外内存消耗最小")]),a._v(" "),i("li",[a._v("在单核处理器环境工作优秀")]),a._v(" "),i("li",[a._v("进行垃圾收集时，必须暂停其他所有工作线程(stop the world)"),i("br"),i("br"),a._v(" "),i("img",{attrs:{src:"/images/interview/iw-serial.png",alt:""}})])])]),a._v(" "),i("li",[i("p",[a._v("ParNew 收集器")]),a._v(" "),i("ul",[i("li",[a._v("新生代收集器")]),a._v(" "),i("li",[a._v("标记-复制算法")]),a._v(" "),i("li",[a._v("多线程并行")]),a._v(" "),i("li",[a._v("能与CMS收集器配合工作(Serial在JDK9及以后就不能再与CMS配合工作了)")]),a._v(" "),i("li",[a._v("激活CMS：-XX:+UseConcMarkSweepGC,默认的新生代收集器就是ParNew")]),a._v(" "),i("li",[a._v("强制指定或者禁用： -XX:+/-UseParNewGC")]),a._v(" "),i("li",[a._v("JDK9后，在服务端官方推荐的G1，不再是ParNew+CMS")]),a._v(" "),i("li",[a._v("参数：-XX:ParallelGCThreads 限制垃圾收集的线程数"),i("br"),i("br"),a._v(" "),i("img",{attrs:{src:"/images/interview/iw-parnew.png",alt:""}})])])]),a._v(" "),i("li",[i("p",[a._v("Parallel Scavenge 收集器")]),a._v(" "),i("ul",[i("li",[a._v("新生代收集器")]),a._v(" "),i("li",[a._v("标记-复制算法")]),a._v(" "),i("li",[a._v("多线程")]),a._v(" "),i("li",[a._v("制定吞吐率规则")]),a._v(" "),i("li",[a._v("-XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间"),i("br"),a._v("\n注意：垃圾停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的")]),a._v(" "),i("li",[a._v("-XX:GCTimeRatio 设置吞吐量大小，垃圾收集时间占总时间的比率")]),a._v(" "),i("li",[a._v("-XX:+UseAdaptiveSizePolicy,开启后不需要指定新生代，存活区，晋升老年代等参数。自适应的调节策略。"),i("br"),i("br"),a._v(" "),i("img",{attrs:{src:"/images/interview/iw-parallel.png",alt:""}})])])]),a._v(" "),i("li",[i("p",[a._v("Serial Old 收集器")]),a._v(" "),i("ul",[i("li",[a._v("老年代收集器")]),a._v(" "),i("li",[a._v("单线程")]),a._v(" "),i("li",[a._v("与Parallel Scavenge 搭配使用")]),a._v(" "),i("li",[a._v("作为CMS收集器发生失败后的备用方案")])])]),a._v(" "),i("li",[i("p",[a._v("Parallel Old 收集器")]),a._v(" "),i("ul",[i("li",[a._v("老年代收集器")]),a._v(" "),i("li",[a._v("多线程")]),a._v(" "),i("li",[a._v("标记-整理算法")]),a._v(" "),i("li",[a._v("与Parallel Scavenge 配合使用，吞吐量优先组合")])])]),a._v(" "),i("li",[i("p",[a._v("CMS 收集器")]),a._v(" "),i("ul",[i("li",[a._v("老年代收集器")]),a._v(" "),i("li",[a._v("以获取最短回收停顿时间为目标")]),a._v(" "),i("li",[a._v("多线程并发收集")]),a._v(" "),i("li",[a._v("标记-清除算法\n"),i("ul",[i("li",[a._v("初始标记(CMS initial mark) stw")]),a._v(" "),i("li",[a._v("并发标记(CMS concurrent mark)")]),a._v(" "),i("li",[a._v("重新标记(CMS remark) stw")]),a._v(" "),i("li",[a._v("并发清除(CMS concurrent sweep)")])])]),a._v(" "),i("li",[a._v("明显的缺点：\n"),i("ul",[i("li",[a._v("CMS收集器对处理器资源非常敏感：默认启动回收线程(处理器核心数量+3)/4，核心数不足4时，影响很大。")]),a._v(" "),i("li",[a._v("CMS无法处理“浮动垃圾”，有可能出现“concurrent mode failure”失败进而导致另一次完全的“STW”的full GC.JDK5默认老年代\n68%负荷触发收集，JDK6默认92%触发收集。CMS运行期间内存无法满足分配新对象，就会出现并发失败，这时将启用备用的Serial Old,\n导致更长时间的停顿。-XX:CMSInitiatingOccupancyFraction设置太高，就容易导致大量的并发失败。")]),a._v(" "),i("li",[a._v("标记-清除算法会产生大量空间碎片。空间碎片过多，分配大对象的内存空间带来的大问题。无法找到足够大的连续空间，而不得不提前触发\n一次Full GC. -XX:+UseCMSCompactAtFullCollection(默认开启，JDK9开始废弃)，用于在CMS收集器不得不进行Full GC时，开启内存碎片\n的合并整理过程。-XX:CMSFullGCsBeforeCompaction(JDK9开始废弃)，在若干次不整理空间的Full GC后，下一次进入Full GC前会先进行碎片\n整理"),i("br"),i("br"),a._v(" "),i("img",{attrs:{src:"/images/interview/iw-cms.png",alt:""}})])])])])]),a._v(" "),i("li",[i("p",[a._v("Garbage First 收集器")]),a._v(" "),i("ul",[i("li",[a._v("垃圾收集器技术历史上里程碑式的成果")]),a._v(" "),i("li",[a._v("JDK7 Update4后可商用；JDK8 Update40 完成类卸载的最后预期功能；JDK9 服务端下默认的垃圾收集器。")]),a._v(" "),i("li",[a._v("G1理念：G1之前的垃圾收集器，收集的目标要么是整个新生代(Minor GC),要么是整个老年代(Major GC)，再就是整个Java堆(Full GC)。而G1\n收集的标准不再是分代，而是哪块内存中存放的垃圾最多，回收收益最大，这就是G1收集器的Mixed GC模式。")]),a._v(" "),i("li",[a._v("Region堆内存布局\n"),i("ul",[i("li",[a._v("堆划分为多个大小相等的独立区域(Region)")]),a._v(" "),i("li",[a._v("每个Region根据需要，扮演Eden,survivor,老年代")]),a._v(" "),i("li",[a._v("对不同角色的Region采用不同的策略去处理")]),a._v(" "),i("li",[a._v("Humongous: 特殊的Region,专门用来存储大对象。超过region一半容量，G1就视为是大对象。(-XX:G1HeapRegionSize,取值范围1-32MB，\n2 的N次幂，超过一个region的对象，将在N个连续的Humongous中存放)")])])]),a._v(" "),i("li",[a._v("-XX:MaxGCPauseMillis : 设定允许的收集停顿时间，默认是200ms")]),a._v(" "),i("li",[a._v("G1面对的问题：\n"),i("ul",[i("li",[a._v("跨Region引用对象：每个region维护一个记忆集，这个记忆集本质是哈希表，key是其他region的首地址。(多份记忆集/卡表，导致占用内存高)")]),a._v(" "),i("li",[a._v("并发标记：原始快照算法")]),a._v(" "),i("li",[a._v("可靠的停顿预测模型：衰减均值，更准确的代表“最近的”平局状态")])])]),a._v(" "),i("li",[a._v("收集动作：\n"),i("ul",[i("li",[a._v("初始标记")]),a._v(" "),i("li",[a._v("并发标记")]),a._v(" "),i("li",[a._v("最终标记")]),a._v(" "),i("li",[a._v("筛选回收"),i("br"),a._v(" "),i("img",{attrs:{src:"/images/interview/iw-g1.png",alt:""}})])])]),a._v(" "),i("li",[a._v("整体上标记-整理，局部上是标记-复制。G1运行期间不会产生内存空间碎片")]),a._v(" "),i("li",[a._v("G1为了垃圾收集产生的内存占用和程序运行时的额外负载比CMS要高")]),a._v(" "),i("li",[a._v("小内存上CMS比G1优秀，大内存6G-8G场景G1比CMS优秀。")]),a._v(" "),i("li",[a._v("设置过小的停顿时间，导致每次收集的垃圾少，但是累积的垃圾多，容易造成Full GC")])])]),a._v(" "),i("li",[i("p",[a._v("Shenandoah 收集器")]),a._v(" "),i("ul",[i("li",[a._v("RadHat公司赠送给OpenJDK,预计在OpenJdk12上搭载")]),a._v(" "),i("li",[a._v("基于Region布局")]),a._v(" "),i("li",[a._v("与G1不同之处\n"),i("ul",[i("li",[a._v("并发整理算法")]),a._v(" "),i("li",[a._v("默认不使用分代收集")]),a._v(" "),i("li",[a._v('摒弃耗费大量内存和计算资源的记忆集，采用名为"连接矩阵"')])])])])]),a._v(" "),i("li",[i("p",[a._v("ZGC 收集器")]),a._v(" "),i("ul",[i("li",[a._v("Oracel血统的未来新星收集器")]),a._v(" "),i("li",[a._v("立下flag停顿时间不超过10ms")]),a._v(" "),i("li",[a._v("JDK11已搭载实验版")]),a._v(" "),i("li",[a._v("基于Region布局(动态性：动态创建和销毁，动态的容量大小)\n"),i("ul",[i("li",[a._v("Small Region => 2mb(存放小于256k的小对象)")]),a._v(" "),i("li",[a._v("MeDIUM Region => 32mb(存放大于256.小于4MB的对象)")]),a._v(" "),i("li",[a._v("Large Region => 容量不固定，2的整数倍(存放大于4MB的对象)")])])]),a._v(" "),i("li",[a._v("不使用记忆集，无分代")]),a._v(" "),i("li",[a._v("并发的标记整理算法\n"),i("ul",[i("li",[a._v("染色指针 ： 64位指针的高18位不能用来寻址，剩下46位的高4位取出来用于存储标记信息")])])]),a._v(" "),i("li",[a._v("收集动作：\n"),i("ul",[i("li",[a._v("并发标记")]),a._v(" "),i("li",[a._v("并发预备重分组")]),a._v(" "),i("li",[a._v("并发重分配")]),a._v(" "),i("li",[a._v("并发重映射")])])])])])]),a._v(" "),i("h3",{attrs:{id:"查看jvm日志命令"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#查看jvm日志命令"}},[a._v("#")]),a._v(" 查看JVM日志命令")]),a._v(" "),i("ul",[i("li",[i("p",[a._v("查看GC基本信息")]),a._v(" "),i("ul",[i("li",[a._v("JDK9之前 ： -XX:+PrintGC")]),a._v(" "),i("li",[a._v("JDK9之后 ：-Xlog:gc")])])]),a._v(" "),i("li",[i("p",[a._v("查看GC详细信息")]),a._v(" "),i("ul",[i("li",[a._v("JDK9之前 ： -XX:+PrintGCDetails")]),a._v(" "),i("li",[a._v("JDK9之后 ： -X-log:gc*")])])]),a._v(" "),i("li",[i("p",[a._v("查看GC前后的堆，方法区可用容量变化")]),a._v(" "),i("ul",[i("li",[a._v("JDK9之前：-XX:+PrintHeapAtGC")]),a._v(" "),i("li",[a._v("JDK9之后： -Xlog:gc+heap=debug")])])]),a._v(" "),i("li",[i("p",[a._v("查看GC过程中用户线程并发时间以及停顿的时间")]),a._v(" "),i("ul",[i("li",[a._v("JDK9之前：-XX:+PrintGCApplicationConcurrentTime，-XX:+PrintGCApplicationStoppedTime")]),a._v(" "),i("li",[a._v("JDK9之后： -Xlog:sagepoint")])])]),a._v(" "),i("li",[i("p",[a._v("查看收集器Ergonomics机制(自动设置对空间各分代区域大小，收集目标等内容，从Parallel收集器开始支持)自动调节的相关信息")]),a._v(" "),i("ul",[i("li",[a._v("JDK9之前：-XX:+PrintAdaptiveSizePolicy")]),a._v(" "),i("li",[a._v("JDK9之后： -Xlog:gc+ergo*=trace")])])]),a._v(" "),i("li",[i("p",[a._v("查看熬过收集后剩余对象的年龄分布信息")]),a._v(" "),i("ul",[i("li",[a._v("JDK9之前：-XX:+PrintTenuringDistribution")]),a._v(" "),i("li",[a._v("JDK9之后： -Xlog:gc+age=trace")])])])]),a._v(" "),i("h3",{attrs:{id:"内存分配与回收策略"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#内存分配与回收策略"}},[a._v("#")]),a._v(" 内存分配与回收策略")]),a._v(" "),i("ul",[i("li",[a._v("对象优先在Eden分配\n"),i("ul",[i("li",[a._v("-Xms20M 最小堆")]),a._v(" "),i("li",[a._v("-Xmx20M 最大堆")]),a._v(" "),i("li",[a._v("-Xmn10M 新生代分配10M")]),a._v(" "),i("li",[a._v("-XX:SurvivorRatio=8 Eden与一个Survivor区的比例是8:1")])])]),a._v(" "),i("li",[a._v("大对象直接进入老年代\n"),i("ul",[i("li",[a._v("XX:PretenureSizeThreshold=3145728(3M大小)"),i("br"),a._v("\n大于这个值的对象直接进入老年代区，只对Serial和ParNew两款新生代收集器有效")])])]),a._v(" "),i("li",[a._v("长期存活对象将进入老年代\n"),i("ul",[i("li",[a._v("-XX:MaxTenuringThreshold=15(默认15)，新生代对象每熬过一次Minor GC年龄加1，增加到15岁时，将晋升到老年代")])])]),a._v(" "),i("li",[a._v("动态对象年龄判定\n"),i("ul",[i("li",[a._v("为了适应不同程序的内存状况，并不总是要求对象的年龄达到设定值才晋升到老年代。在Survivor区相同年龄的所有对象大小的总和\n大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入到老年代了。")])])]),a._v(" "),i("li",[a._v("空间分配担保\n"),i("ul",[i("li",[a._v("发生Minor GC之前将检查，老年代最大可用空间是否大于新生代所有对象总空间\n"),i("ul",[i("li",[a._v("大于，那么即使此时新生代所有对象一起晋升老年代也是没有风险的，可以进行Minor GC")]),a._v(" "),i("li",[a._v("小于，有风险。继续检查-XX:HandlePromotionFailure参数的值\n"),i("ul",[i("li",[a._v("true: 检查老年代最大可用空间是否大于历史上晋升到老年代对象的平均大小。\n"),i("ul",[i("li",[a._v("大于，尝试进行一次Minor GC ，伴随隐藏风险")]),a._v(" "),i("li",[a._v("小于，Full GC")])])]),a._v(" "),i("li",[a._v("false: Full GC")])])])])])])])]),a._v(" "),i("h2",{attrs:{id:"虚拟机性能监控工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机性能监控工具"}},[a._v("#")]),a._v(" 虚拟机性能监控工具")]),a._v(" "),i("p",[a._v("以Window环境的JDK为例，各种工具都在 JAVA_HOME\\bin 目录下。"),i("br"),a._v("\n根据软件可用性和授权的不同，可以把它们划分成三类：")]),a._v(" "),i("ul",[i("li",[a._v("商业授权工具：主要是JMC(java mission control)及它要使用到的JFR(java flight recorder),JMC这个原本来自于JRockit的运维监控套件\n从JDK7 Update 40开始就被集成到OracleJDK中，JDK11之前都无须独立下载，但是在商业环境中使用它则是要付费的。")]),a._v(" "),i("li",[a._v("正式支持工具：这一类工具属于被长期支持的工具，不同平台，不同版本的JDK之间，这类工具可能会略有差异，但是不会出现某一个工具突然消失的情况")]),a._v(" "),i("li",[a._v("实验性质工具：这一类工具在他们的使用说明中被声明为“没有技术支持，并且是实验性质的”产品，日后可能会转正，也可能会在某个JDK版本中无声无息的消失。\n但事实上他们通常都非常稳定而且功能强大，也能在处理应用程序性能问题，定位故障时发挥很大的作用。、")])]),a._v(" "),i("div",{staticClass:"custom-block danger"},[i("p",{staticClass:"custom-block-title"},[a._v("WARNING")]),a._v(" "),i("p",[a._v("由于大部分工具都是基于或者需要用到JMX"),i("br"),a._v('\n1.监控运行与JDK5上的应用，启动时需要添加参数""-Dcom.sun.management.jmxremote" 开启JMX管理功能'),i("br"),a._v("\n2.JDK6或以上版本，JMX默认是打开的")])]),a._v(" "),i("h3",{attrs:{id:"基础故障处理工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#基础故障处理工具"}},[a._v("#")]),a._v(" 基础故障处理工具")]),a._v(" "),i("h4",{attrs:{id:"jps-虚拟机进程状况工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#jps-虚拟机进程状况工具"}},[a._v("#")]),a._v(" jps:虚拟机进程状况工具")]),a._v(" "),i("p",[a._v("JPS(JVM Process Status Tool) 列出正在运行的虚拟机进程，并显示虚拟机执行主类名称已经这些进程的本地虚拟机唯一ID(LVMID,Local Virtual Machine Identifier)。\n对于本地虚拟机进程来说，LVMID与操作系统的进程ID(PID,Process Identifier)是一致的。")]),a._v(" "),i("ul",[i("li",[a._v("命令格式：jps [options] [hostid]\n"),i("ul",[i("li",[a._v("-q  只输出LVMID,省略主类的名称")]),a._v(" "),i("li",[a._v("-m  输出虚拟机进程启动时传递给主类main()函数的参数")]),a._v(" "),i("li",[a._v("-l  输出主类的全名，如果进程执行的是JAR包，则输出JAR路径")]),a._v(" "),i("li",[a._v("-v  输出虚拟机进程启动时的JVM参数")]),a._v(" "),i("li",[a._v("查询远程主机上虚拟机进程状态，需要输入hostid")])])]),a._v(" "),i("li",[a._v("win10环境示例：\n"),i("img",{attrs:{src:"/images/interview/jps-1.png",alt:""}})])]),a._v(" "),i("h4",{attrs:{id:"jstat-虚拟机统计信息监视工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#jstat-虚拟机统计信息监视工具"}},[a._v("#")]),a._v(" jstat:虚拟机统计信息监视工具")]),a._v(" "),i("p",[a._v("jstat(JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类加载，\n内存，垃圾收集，即时编译等运行时数据。")]),a._v(" "),i("ul",[i("li",[a._v("命令格式： jstat [options vmid [interval][s|ms] [count]]\n"),i("ul",[i("li",[a._v("VMID：如果是在本地VMID就是LVMID,如果是远程虚拟机进程，VMID格式为："),i("br"),a._v("\n[protocol:][//]lvmid[@hostname[:port]/servername]")]),a._v(" "),i("li",[a._v("intercal 查询间隔")]),a._v(" "),i("li",[a._v("count 次数")]),a._v(" "),i("li",[a._v("option\n"),i("ul",[i("li",[a._v("-class 监视类加载，卸载数量，总空间以及类转载所耗费的时间")]),a._v(" "),i("li",[a._v("-gc 监视Java堆状况，包括Eden区，2个Survivor区，老年代，永久代等的容量，已用空间，垃圾收集时间合集等信息")]),a._v(" "),i("li",[a._v("-gccapacity 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间")]),a._v(" "),i("li",[a._v("-gcutil 监视内容与-gc基本相同，但输出主要关注已使用空间站总空间的百分比")]),a._v(" "),i("li",[a._v("-gccause 与-gcutil功能一样，但是会额外输出导致上一次垃圾收集产生的原因")])])])])]),a._v(" "),i("li",[a._v("win10环境示例")])]),a._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[a._v("C:\\Users\\f117>jps -l\n6592\n2164 org.jetbrains.idea.maven.server.RemoteMavenServer\n13852 org.jetbrains.jps.cmdline.Launcher\n17596 sun.tools.jps.Jps\n\nC:\\Users\\f117>jstat -gcutil 13852\n  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT\n  0.00   0.00  90.49   0.00  17.18  19.75      0    0.000     0    0.000    0.000\n")])]),a._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[a._v("1")]),i("br"),i("span",{staticClass:"line-number"},[a._v("2")]),i("br"),i("span",{staticClass:"line-number"},[a._v("3")]),i("br"),i("span",{staticClass:"line-number"},[a._v("4")]),i("br"),i("span",{staticClass:"line-number"},[a._v("5")]),i("br"),i("span",{staticClass:"line-number"},[a._v("6")]),i("br"),i("span",{staticClass:"line-number"},[a._v("7")]),i("br"),i("span",{staticClass:"line-number"},[a._v("8")]),i("br"),i("span",{staticClass:"line-number"},[a._v("9")]),i("br")])]),i("h4",{attrs:{id:"jinfo-java配置信息工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#jinfo-java配置信息工具"}},[a._v("#")]),a._v(" jinfo:Java配置信息工具")]),a._v(" "),i("p",[a._v("jinfo(Configuration Info for Java)的作用是实时查看和调整虚拟机各项参数。")]),a._v(" "),i("ul",[i("li",[a._v("命令格式： jinfo [option] pid")]),a._v(" "),i("li",[a._v("win10环境示例")])]),a._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[a._v("C:\\Users\\f117>jinfo -flag SurvivorRatio 13852\n-XX:SurvivorRatio=8\n")])]),a._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[a._v("1")]),i("br"),i("span",{staticClass:"line-number"},[a._v("2")]),i("br")])]),i("h4",{attrs:{id:"jmap-java内存映像工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#jmap-java内存映像工具"}},[a._v("#")]),a._v(" jmap:Java内存映像工具")]),a._v(" "),i("p",[a._v("jmap(Memory Map for Java)命令用于生成堆转储快照(一般称为heapdump或dump文件)。如果不使用jmap命令，要想获取Java堆转储快照也还有一些比较\n“暴力”的手段："),i("br"),a._v(" -XX:HeapDumpOnOutOfMemoryError参数，可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件，通过-XX:+HeapDumpOnCtrlBreak\n参数则可以使用Ctrl+Break键让虚拟机生成堆转储快照文件，又或者在Linux系统下通过kill -3发送进程退出信号“恐吓”一下虚拟机，也能顺利拿到堆转储快照。"),i("br"),a._v("\njmap的作用并不仅仅是为了获取堆转储快照，它还可以查询finalize执行队列，Java堆和方法区的详细信息，如空间使用率，当前用的是哪种收集器")]),a._v(" "),i("ul",[i("li",[a._v("命令格式： jmap [option] vmid\n"),i("ul",[i("li",[a._v("option\n"),i("ul",[i("li",[a._v("-dump 生成Java堆转储快照。格式为 -dump:[live,]format=b,file=<filename>,其中live子参数说明是否只dump出存活的对象")]),a._v(" "),i("li",[a._v("-finalizerinfo 显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效")]),a._v(" "),i("li",[a._v("-heap 显示Java堆详细信息，如使用哪种回收器，参数配置，分代状况等。只在Linux/Solaris平台下有效")]),a._v(" "),i("li",[a._v("-histo 显示堆中对象统计信息，包括类，实例数量，合集容量")]),a._v(" "),i("li",[a._v("-premstat 以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效")]),a._v(" "),i("li",[a._v("-F 当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效")])])])])]),a._v(" "),i("li",[a._v("win10环境下示例：")])]),a._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[a._v("C:\\Users\\f117>jmap -dump:format=b,file=idea.bin 6592\nDumping heap to C:\\Users\\f117\\idea.bin ...\nHeap dump file created\n")])]),a._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[a._v("1")]),i("br"),i("span",{staticClass:"line-number"},[a._v("2")]),i("br"),i("span",{staticClass:"line-number"},[a._v("3")]),i("br")])]),i("h4",{attrs:{id:"jhat-虚拟机堆转储快照分析工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#jhat-虚拟机堆转储快照分析工具"}},[a._v("#")]),a._v(" jhat:虚拟机堆转储快照分析工具")]),a._v(" "),i("p",[a._v("JDK提供jhat(JVM Heap Analysis Tool)命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照\n分析结果后，可以在浏览器中查看。一般不会用jhat分析，在当前机器上分析耗费计算资源。一般将堆转储快照文件转移到其他机器上，再使用其他更有效率的\n工具来分析。")]),a._v(" "),i("ul",[i("li",[a._v("win10环境示例(吐槽一下：分析过程CPU持续在90%以上)")])]),a._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[a._v("C:\\Users\\f117>jhat idea.bin\nReading from idea.bin...\nDump file created Fri Apr 17 17:32:05 CST 2020\nSnapshot read, resolving...\nResolving 11276003 objects...\nChasing references, expect 2255 dots.......\nEliminating duplicate references......\nSnapshot resolved.\nStarted HTTP server on port 7000\nServer is ready.\n")])]),a._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[a._v("1")]),i("br"),i("span",{staticClass:"line-number"},[a._v("2")]),i("br"),i("span",{staticClass:"line-number"},[a._v("3")]),i("br"),i("span",{staticClass:"line-number"},[a._v("4")]),i("br"),i("span",{staticClass:"line-number"},[a._v("5")]),i("br"),i("span",{staticClass:"line-number"},[a._v("6")]),i("br"),i("span",{staticClass:"line-number"},[a._v("7")]),i("br"),i("span",{staticClass:"line-number"},[a._v("8")]),i("br"),i("span",{staticClass:"line-number"},[a._v("9")]),i("br"),i("span",{staticClass:"line-number"},[a._v("10")]),i("br")])]),i("p",[a._v("访问localhost:7000\n"),i("img",{attrs:{src:"/images/interview/jhat-1.png",alt:""}})]),a._v(" "),i("h4",{attrs:{id:"jstack-java堆栈跟踪工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#jstack-java堆栈跟踪工具"}},[a._v("#")]),a._v(" jstack:Java堆栈跟踪工具")]),a._v(" "),i("p",[a._v("jstack(Stack Trace for Java)命令用于生成虚拟机当前时刻的线程快照(一般称为threaddump或者javacore文件)。")]),a._v(" "),i("ul",[i("li",[a._v("命令格式： jstack [option] vmid\n"),i("ul",[i("li",[a._v("option\n"),i("ul",[i("li",[a._v("-F 当正常输出的请求不被响应时，强制输出线程堆栈")]),a._v(" "),i("li",[a._v("-l 除了堆栈外，显示关于锁的附加信息")]),a._v(" "),i("li",[a._v("-m 如果调用到本地方法的话，可以显示C/C++的堆栈")])])])])]),a._v(" "),i("li",[a._v("win10环境下示例：")])]),a._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[a._v('C:\\Users\\f117>jstack -l 6592\n2020-04-17 17:53:00\nFull thread dump OpenJDK 64-Bit Server VM (25.202-b39 mixed mode):\n\n"JobScheduler FJ pool 3/7" #13213 daemon prio=4 os_prio=-1 tid=0x0000000069230800 nid=0x3b7c waiting on condition [0x00000000745af000]\n   java.lang.Thread.State: TIMED_WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000aa9350e0> (a java.util.concurrent.ForkJoinPool)\n        at java.util.concurrent.ForkJoinPool.awaitWork(ForkJoinPool.java:1824)\n        at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1693)\n        at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)\n\n   Locked ownable synchronizers:\n        - None\n\n"JobScheduler FJ pool 6/7" #13212 daemon prio=4 os_prio=-1 tid=0x000000015f3c6000 nid=0x1424 waiting on condition [0x00000000739cf000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000aa9350e0> (a java.util.concurrent.ForkJoinPool)\n        at java.util.concurrent.ForkJoinPool.awaitWork(ForkJoinPool.java:1824)\n        at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1693)\n        at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)\n\n   Locked ownable synchronizers:\n        - None\n\n"Process I/O pool 1059" #13210 prio=4 os_prio=-1 tid=0x000000015f3cb800 nid=0x4718 waiting on condition [0x000000016c16f000]\n   java.lang.Thread.State: TIMED_WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000ace4f608> (a java.util.concurrent.SynchronousQueue$TransferStack)\n        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)\n        at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:460)\n        at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:362)\n        at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:941)\n        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1073)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n        at java.lang.Thread.run(Thread.java:748)\n\n   Locked ownable synchronizers:\n        - None\n\n.......\n')])]),a._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[a._v("1")]),i("br"),i("span",{staticClass:"line-number"},[a._v("2")]),i("br"),i("span",{staticClass:"line-number"},[a._v("3")]),i("br"),i("span",{staticClass:"line-number"},[a._v("4")]),i("br"),i("span",{staticClass:"line-number"},[a._v("5")]),i("br"),i("span",{staticClass:"line-number"},[a._v("6")]),i("br"),i("span",{staticClass:"line-number"},[a._v("7")]),i("br"),i("span",{staticClass:"line-number"},[a._v("8")]),i("br"),i("span",{staticClass:"line-number"},[a._v("9")]),i("br"),i("span",{staticClass:"line-number"},[a._v("10")]),i("br"),i("span",{staticClass:"line-number"},[a._v("11")]),i("br"),i("span",{staticClass:"line-number"},[a._v("12")]),i("br"),i("span",{staticClass:"line-number"},[a._v("13")]),i("br"),i("span",{staticClass:"line-number"},[a._v("14")]),i("br"),i("span",{staticClass:"line-number"},[a._v("15")]),i("br"),i("span",{staticClass:"line-number"},[a._v("16")]),i("br"),i("span",{staticClass:"line-number"},[a._v("17")]),i("br"),i("span",{staticClass:"line-number"},[a._v("18")]),i("br"),i("span",{staticClass:"line-number"},[a._v("19")]),i("br"),i("span",{staticClass:"line-number"},[a._v("20")]),i("br"),i("span",{staticClass:"line-number"},[a._v("21")]),i("br"),i("span",{staticClass:"line-number"},[a._v("22")]),i("br"),i("span",{staticClass:"line-number"},[a._v("23")]),i("br"),i("span",{staticClass:"line-number"},[a._v("24")]),i("br"),i("span",{staticClass:"line-number"},[a._v("25")]),i("br"),i("span",{staticClass:"line-number"},[a._v("26")]),i("br"),i("span",{staticClass:"line-number"},[a._v("27")]),i("br"),i("span",{staticClass:"line-number"},[a._v("28")]),i("br"),i("span",{staticClass:"line-number"},[a._v("29")]),i("br"),i("span",{staticClass:"line-number"},[a._v("30")]),i("br"),i("span",{staticClass:"line-number"},[a._v("31")]),i("br"),i("span",{staticClass:"line-number"},[a._v("32")]),i("br"),i("span",{staticClass:"line-number"},[a._v("33")]),i("br"),i("span",{staticClass:"line-number"},[a._v("34")]),i("br"),i("span",{staticClass:"line-number"},[a._v("35")]),i("br"),i("span",{staticClass:"line-number"},[a._v("36")]),i("br"),i("span",{staticClass:"line-number"},[a._v("37")]),i("br"),i("span",{staticClass:"line-number"},[a._v("38")]),i("br"),i("span",{staticClass:"line-number"},[a._v("39")]),i("br"),i("span",{staticClass:"line-number"},[a._v("40")]),i("br"),i("span",{staticClass:"line-number"},[a._v("41")]),i("br"),i("span",{staticClass:"line-number"},[a._v("42")]),i("br"),i("span",{staticClass:"line-number"},[a._v("43")]),i("br")])]),i("h4",{attrs:{id:"更多工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#更多工具"}},[a._v("#")]),a._v(" 更多工具")]),a._v(" "),i("p",[a._v("....")]),a._v(" "),i("h3",{attrs:{id:"可视化故障处理工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#可视化故障处理工具"}},[a._v("#")]),a._v(" 可视化故障处理工具")]),a._v(" "),i("h4",{attrs:{id:"jhsdb-基于服务性代理的调试工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#jhsdb-基于服务性代理的调试工具"}},[a._v("#")]),a._v(" JHSDB:基于服务性代理的调试工具")]),a._v(" "),i("ul",[i("li",[a._v("JDK9正式提供")])]),a._v(" "),i("h4",{attrs:{id:"jconsole-java监视与管理控制台"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#jconsole-java监视与管理控制台"}},[a._v("#")]),a._v(" JConsole:Java监视与管理控制台")]),a._v(" "),i("ul",[i("li",[a._v("基于JMX的可视化监视，管理工具")]),a._v(" "),i("li",[a._v("内存监控")]),a._v(" "),i("li",[a._v("线程监控")])]),a._v(" "),i("h4",{attrs:{id:"visualvm-多合一故障处理工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#visualvm-多合一故障处理工具"}},[a._v("#")]),a._v(" VisualVM:多合一故障处理工具")]),a._v(" "),i("ul",[i("li",[a._v("对应用程序实际性能较小，可直接应用于生产环境")]),a._v(" "),i("li",[a._v("在插件扩展支持下：\n"),i("ul",[i("li",[a._v("显示虚拟机进程已经进程的配置、环境信息(jps,jinfo)")]),a._v(" "),i("li",[a._v("监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息(jstat,jstack)")]),a._v(" "),i("li",[a._v("dump以及分析堆转储快照(jmap,jhat)")]),a._v(" "),i("li",[a._v("方法级的程序运行性能分析，找出被调用最多，运行时间最长的方法")]),a._v(" "),i("li",[a._v("离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈")]),a._v(" "),i("li",[a._v("其他插件带来的无限可能性")])])])]),a._v(" "),i("h4",{attrs:{id:"java-mission-control-可持续在线的监控工具"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#java-mission-control-可持续在线的监控工具"}},[a._v("#")]),a._v(" Java Mission Control:可持续在线的监控工具")]),a._v(" "),i("ul",[i("li",[a._v("收费特性")])]),a._v(" "),i("h2",{attrs:{id:"调优策略"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#调优策略"}},[a._v("#")]),a._v(" 调优策略")]),a._v(" "),i("ul",[i("li",[a._v("1.选择合适的收集器组合\n"),i("ul",[i("li",[a._v("计算密集型应用(多核CPU)\n"),i("ul",[i("li",[a._v("JDK9以前 ：Parallel Scavenge + Parallel Old")]),a._v(" "),i("li",[a._v("JDK9及以后 ： G1")]),a._v(" "),i("li",[a._v("JDK12: ZGC")])])]),a._v(" "),i("li",[a._v("IO密集型应用(多核CPU)\n"),i("ul",[i("li",[a._v("JDK9以前 ：ParNew + CMS + Serial Old")]),a._v(" "),i("li",[a._v("JDK9及以后 ： G1")]),a._v(" "),i("li",[a._v("JDK12: ZGC : ZGC")])])])])]),a._v(" "),i("li",[a._v("2.ZGC以前都是分代收集\n"),i("ul",[i("li",[a._v("新生代内存占比")]),a._v(" "),i("li",[a._v("Survivor区内存占比")]),a._v(" "),i("li",[a._v("晋升老年代策略")]),a._v(" "),i("li",[a._v("Full GC触发控制")])])]),a._v(" "),i("li",[a._v("3.堆转储分析OOM，修复优化代码")]),a._v(" "),i("li",[a._v("4.VisualVM 分析热点方法，分析耗时最长方法")]),a._v(" "),i("li",[a._v("5.代码编译器优化")])]),a._v(" "),i("h2",{attrs:{id:"虚拟机类加载"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机类加载"}},[a._v("#")]),a._v(" 虚拟机类加载")]),a._v(" "),i("h3",{attrs:{id:"类加载的时机"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#类加载的时机"}},[a._v("#")]),a._v(" 类加载的时机")]),a._v(" "),i("p",[i("img",{attrs:{src:"/images/interview/iw-23.png",alt:""}})]),a._v(" "),i("ul",[i("li",[i("p",[a._v("加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。")])]),a._v(" "),i("li",[i("p",[a._v("解析阶段顺序不确定，在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性(动态绑定或晚期绑定)")])]),a._v(" "),i("li",[i("p",[a._v("加载的顺序是按照这个顺序开始，而不是一个完成之后，再开始另外一个。这些阶段在进行的过程中就会触发另一个的开始")])]),a._v(" "),i("li",[i("p",[a._v("加载："),i("br")]),a._v(" "),i("ul",[i("li",[a._v("遇到new、getstatic、putstatic或invokestatic 这四条字节码指令，如果类型没有进行初始化，则需要先触发其初始化阶段。\n"),i("ul",[i("li",[a._v("使用new关键字实例化对象时")]),a._v(" "),i("li",[a._v("读取或设置一个类型的静态字段(被final修饰，在编辑期把结果放入常量池的静态字段除外)的时候")]),a._v(" "),i("li",[a._v("调用一个类型的静态方法时")])])]),a._v(" "),i("li",[a._v("使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化")]),a._v(" "),i("li",[a._v("当初始化类的时候，如果发现其父类还没有初始化，则需要先触发父类的初始化")]),a._v(" "),i("li",[a._v("当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类")]),a._v(" "),i("li",[a._v("当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic,REF_putStatic,\nREF_invokeStatic,REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化")]),a._v(" "),i("li",[a._v("当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那接口要再其之前\n被初始化")])])])]),a._v(" "),i("div",{staticClass:"custom-block warning"},[i("p",{staticClass:"custom-block-title"},[a._v("WARNING")]),a._v(" "),i("p",[a._v("当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化是，并不要求其父接口全部都完成初始化，只有在真正使用到父接口\n的时候(如引用接口中定义的常量)才会初始化")])]),a._v(" "),i("p",[a._v("###类加载的过程")]),a._v(" "),i("ul",[i("li",[a._v("加载\n"),i("ul",[i("li",[a._v("通过一个类的全限定名来获取定义此类的二进制字节流\n"),i("ul",[i("li",[a._v("从ZIP压缩包中读取，这很常见，最终成为日后JAR,EAR,WAR格式的基础")]),a._v(" "),i("li",[a._v("从网络中获取，这种场景最典型的应用就是web applet")]),a._v(" "),i("li",[a._v("运行时计算生成，这种场景使用的最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass\n来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。")]),a._v(" "),i("li",[a._v("由其他文件生成，典型场景就是JSP应用，由JSP文件生成对应的Class文件")]),a._v(" "),i("li",[a._v("从数据库中读取")]),a._v(" "),i("li",[a._v("可以从加密文件中获取，防Class文件被反编译的保护措施")]),a._v(" "),i("li",[a._v(".....")])])]),a._v(" "),i("li",[a._v("将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构")]),a._v(" "),i("li",[a._v("在内存中生成一个代表这个类的java.lang.Class对象。作为方法区这个类的各种数据的访问入口")])])]),a._v(" "),i("li",[a._v("验证\n"),i("ul",[i("li",[a._v("1.文件格式验证")]),a._v(" "),i("li",[a._v("2.元数据验证")]),a._v(" "),i("li",[a._v("3.字节码验证")]),a._v(" "),i("li",[a._v("4.符号引用验证")])])]),a._v(" "),i("li",[a._v("准备\n"),i("ul",[i("li",[a._v("准备阶段是正式为勒种定义的变量(即静态变量，被static修饰的变量)分配内存并设置类变量初始值的阶段。")]),a._v(" "),i("li",[a._v("final static 修饰的变量设置为指定的值")]),a._v(" "),i("li",[a._v("static变量是0值")]),a._v(" "),i("li",[a._v("其他普通变量也是0值")])])]),a._v(" "),i("li",[a._v("解析\n"),i("ul",[i("li",[a._v("解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。")]),a._v(" "),i("li",[a._v("1.类或接口的解析")]),a._v(" "),i("li",[a._v("2.字段解析")]),a._v(" "),i("li",[a._v("3.方法解析")]),a._v(" "),i("li",[a._v("4.接口方法解析")])])]),a._v(" "),i("li",[a._v("初始化\n"),i("ul",[i("li",[a._v("类的初始化是类加载的最后一个步骤。直到初始化阶段，Java虚拟机开真正开始执行类中编写的Java代码，将主导权交给应用程序。")])])])]),a._v(" "),i("h3",{attrs:{id:"类加载器"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),i("ul",[i("li",[i("p",[a._v("双亲委派模型")]),a._v(" "),i("ul",[i("li",[a._v("启动类加载器(Bootstrap Class Loader)")]),a._v(" "),i("li",[a._v("扩展类加载器(Extension Class Loader)")]),a._v(" "),i("li",[a._v("应用程序类加载器(Application Class Loader)")])])]),a._v(" "),i("li",[i("p",[a._v("破坏双亲委派模型")]),a._v(" "),i("ul",[i("li",[a._v("模块化 - OSGI技术")])])])])])}),[],!1,null,null,null);v.default=_.exports}}]);