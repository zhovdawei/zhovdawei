(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{423:function(s,a,e){"use strict";e.r(a);var t=e(42),l=Object(t.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"mysql优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql优化"}},[s._v("#")]),s._v(" mysql优化")]),s._v(" "),e("hr"),s._v(" "),e("h2",{attrs:{id:"sql查询语法顺序和执行熟悉怒"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sql查询语法顺序和执行熟悉怒"}},[s._v("#")]),s._v(" SQL查询语法顺序和执行熟悉怒")]),s._v(" "),e("h3",{attrs:{id:"语法顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法顺序"}},[s._v("#")]),s._v(" 语法顺序")]),s._v(" "),e("ul",[e("li",[e("ol",[e("li",[s._v("SELECT")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[s._v("FROM")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[s._v("LEFT JOIN")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[s._v("ON")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"5"}},[e("li",[s._v("WHERE")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"6"}},[e("li",[s._v("GROUP BY")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"7"}},[e("li",[s._v("HAVING")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"8"}},[e("li",[s._v("ORDER BY")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"9"}},[e("li",[s._v("LIMIT")])])])]),s._v(" "),e("h3",{attrs:{id:"执行顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行顺序"}},[s._v("#")]),s._v(" 执行顺序")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("SELECT * FROM user LEFT JOIN order ON user.id = order.uid WHERE order.price > 1000\nGROUP BY user.name HAVING count(1) > 5 ORDER BY user.name LIMIT 0,10\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("ol",[e("li",[s._v("FROM（将最近的两张表，进行笛卡尔积） ---VT1")]),s._v(" "),e("li",[s._v("ON（将 VT1 按照它的条件进行过滤） ---VT23. LEFT JOIN（保留左表的记录） ---VT3")]),s._v(" "),e("li",[s._v("WHERE（过滤 VT3 中的记录） --VT4…VTn")]),s._v(" "),e("li",[s._v("GROUP BY（对 VT4 的记录进行分组） ---VT5")]),s._v(" "),e("li",[s._v("HAVING（对 VT5 中的记录进行过滤） ---VT6")]),s._v(" "),e("li",[s._v("SELECT（对 VT6 中的记录， 选取指定的列） --VT7")]),s._v(" "),e("li",[s._v("ORDER BY（对 VT7 的记录进行排序） --游标")]),s._v(" "),e("li",[s._v("LIMIT（对排序之后的值进行分页）\n⚫ WHERE 条件执行顺序（影响性能）")]),s._v(" "),e("li",[s._v("MYSQL： 从左往右去执行 WHERE 条件的。")]),s._v(" "),e("li",[s._v("Oracle： 从右往左去执行 WHERE 条件的。")])]),s._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),e("p",[s._v("1.写 WHERE 条件的时候， 优先级高的部分要去编写过滤力度最大的条件语句"),e("br"),s._v("\n2.由于有优化器的存在，where子句的顺序会被系统自动调整为最优")])]),s._v(" "),e("h2",{attrs:{id:"explain执行计划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#explain执行计划"}},[s._v("#")]),s._v(" EXPLAIN执行计划")]),s._v(" "),e("p",[e("img",{attrs:{src:"/images/interview/db-3.png",alt:""}})]),s._v(" "),e("h3",{attrs:{id:"参数说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数说明"}},[s._v("#")]),s._v(" 参数说明")]),s._v(" "),e("p",[s._v("expain 出来的信息有 10 列，分别是 id、 select_type、 table、 type、 possible_keys、 key、 key_len、\nref、 rows、 Extra,下面对这些字段进行解释：")]),s._v(" "),e("ul",[e("li",[s._v("id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.")]),s._v(" "),e("li",[s._v("select_type: SELECT 查询的类型.")]),s._v(" "),e("li",[s._v("table: 查询的是哪个表")]),s._v(" "),e("li",[s._v("partitions: 匹配的分区")]),s._v(" "),e("li",[s._v("type: join 类型")]),s._v(" "),e("li",[s._v("possible_keys: 此次查询中可能选用的索引")]),s._v(" "),e("li",[s._v("key: 此次查询中确切使用到的索引.")]),s._v(" "),e("li",[s._v("ref: 哪个字段或常数与 key 一起被使用")]),s._v(" "),e("li",[s._v("rows: 显示此查询一共扫描了多少行. 这个是一个估计值.")]),s._v(" "),e("li",[s._v("filtered: 表示此查询条件所过滤的数据的百分比")]),s._v(" "),e("li",[s._v("extra: 额外的信息")])]),s._v(" "),e("h3",{attrs:{id:"select-type-列说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#select-type-列说明"}},[s._v("#")]),s._v(" select_type 列说明")]),s._v(" "),e("ul",[e("li",[s._v("SIMPLE, 表示此查询不包含 UNION 查询或子查询")]),s._v(" "),e("li",[s._v("PRIMARY, 表示此查询是最外层的查询")]),s._v(" "),e("li",[s._v("UNION, 表示此查询是 UNION 的第二或随后的查询")]),s._v(" "),e("li",[s._v("DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询")]),s._v(" "),e("li",[s._v("UNION RESULT, UNION 的结果")]),s._v(" "),e("li",[s._v("SUBQUERY, 子查询中的第一个 SELECT")]),s._v(" "),e("li",[s._v("DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查\n询依赖于外层查询的结果")])]),s._v(" "),e("h2",{attrs:{id:"type-列说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#type-列说明"}},[s._v("#")]),s._v(" type 列说明")]),s._v(" "),e("p",[s._v("通常来说, 不同的 type 类型的性能关系如下:"),e("br"),s._v("\nALL < index < range ~ index_merge < ref < eq_ref < const < system")]),s._v(" "),e("ul",[e("li",[s._v("system\n"),e("ul",[e("li",[s._v("表只有一行")])])]),s._v(" "),e("li",[s._v("const\n"),e("ul",[e("li",[s._v("表最多只有一行匹配，通用用于主键或者唯一索引比较时")])])]),s._v(" "),e("li",[s._v("eq_ref\n"),e("ul",[e("li",[s._v("每次与之前的表合并行都只在该表读取一行，这是除了system，const之外最好的一种，特点是使用=，而且索引的所有部分都参与join且索引是主键或非空唯一键的索引")])])]),s._v(" "),e("li",[s._v("ref\n"),e("ul",[e("li",[s._v("如果每次只匹配少数行，那就是比较好的一种，使用=或<=>，可以是左覆盖索引或非主键或非唯一键")])])]),s._v(" "),e("li",[s._v("fulltext\n"),e("ul",[e("li",[s._v("全文搜索")])])]),s._v(" "),e("li",[s._v("ref_or_null\n"),e("ul",[e("li",[s._v("与ref类似，但包括NULL")])])]),s._v(" "),e("li",[s._v("index_merge\n"),e("ul",[e("li",[s._v("表示出现了索引合并优化(包括交集，并集以及交集之间的并集)，但不包括跨表和全文索引。\n这个比较复杂，目前的理解是合并单表的范围索引扫描（如果成本估算比普通的range要更优的话")])])]),s._v(" "),e("li",[s._v("unique_subquery\n"),e("ul",[e("li",[s._v("在in子查询中，就是value in (select...)把形如“select unique_key_column”的子查询替换。\nPS：所以不一定in子句中使用子查询就是低效的！")])])]),s._v(" "),e("li",[s._v("index_subquery\n"),e("ul",[e("li",[s._v("同上，但把形如”select non_unique_key_column“的子查询替换")])])]),s._v(" "),e("li",[s._v("range\n"),e("ul",[e("li",[s._v("常数值的范围")])])]),s._v(" "),e("li",[s._v("index\n"),e("ul",[e("li",[s._v("当查询是索引覆盖的，即所有数据均可从索引树获取的时候（Extra中有Using Index）；")]),s._v(" "),e("li",[s._v("以索引顺序从索引中查找数据行的全表扫描（无 Using Index）；")]),s._v(" "),e("li",[s._v("如果Extra中Using Index与Using Where同时出现的话，则是利用索引查找键值的意思；")]),s._v(" "),e("li",[s._v("如单独出现，则是用读索引来代替读行，但不用于查找\n-all")]),s._v(" "),e("li",[s._v("全表扫描")])])])]),s._v(" "),e("h2",{attrs:{id:"慢查询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#慢查询"}},[s._v("#")]),s._v(" 慢查询")]),s._v(" "),e("h3",{attrs:{id:"开启慢查询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开启慢查询"}},[s._v("#")]),s._v(" 开启慢查询")]),s._v(" "),e("p",[s._v("MySQL 的慢查询日志功能， 默认是关闭的，需要手动开启。\n"),e("img",{attrs:{src:"/images/interview/db-4.png",alt:""}})]),s._v(" "),e("h3",{attrs:{id:"参数说明-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数说明-2"}},[s._v("#")]),s._v(" 参数说明")]),s._v(" "),e("ul",[e("li",[s._v("slow_query_log ：是否开启慢查询日志， ON 为开启， OFF 为关闭，如果为关闭可以开\n启。")]),s._v(" "),e("li",[s._v("log-slow-queries ：旧版（5.6 以下版本） MySQL 数据库慢查询日志存储路径。可以不设置该\n参数，系统则会默认给一个缺省的文件 host_name-slow.log")]),s._v(" "),e("li",[s._v("slow-query-log-file：新版（5.6 及以上版本） MySQL 数据库慢查询日志存储路径。可以不\n设置该参数，系统则会默认给一个缺省的文件 host_name-slow.log")]),s._v(" "),e("li",[s._v("long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志，单位为秒。")])]),s._v(" "),e("h3",{attrs:{id:"临时开启慢查询功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#临时开启慢查询功能"}},[s._v("#")]),s._v(" 临时开启慢查询功能")]),s._v(" "),e("p",[s._v("在 MySQL 执行 SQL 语句设置，但是如果重启 MySQL 的话将失效")]),s._v(" "),e("ul",[e("li",[s._v("set global slow_query_log = ON;")]),s._v(" "),e("li",[s._v("set global long_query_time = 1;")])]),s._v(" "),e("h3",{attrs:{id:"永久开启慢查询功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#永久开启慢查询功能"}},[s._v("#")]),s._v(" 永久开启慢查询功能")]),s._v(" "),e("p",[s._v("修改/etc/my.cnf 配置文件，重启 MySQL, 这种永久生效.\n[mysqld]\nslow_query_log = ON\nslow_query_log_file = /var/log/mysql/slow.log\nlong_query_time = 1")]),s._v(" "),e("h3",{attrs:{id:"查看慢查询的日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看慢查询的日志"}},[s._v("#")]),s._v(" 查看慢查询的日志")]),s._v(" "),e("p",[e("img",{attrs:{src:"/images/interview/db-5.png",alt:""}}),s._v("\n格式说明")]),s._v(" "),e("ul",[e("li",[s._v("第一行,SQL 查询执行的时间")]),s._v(" "),e("li",[s._v("第二行,执行 SQL 查询的连接信息，用户和连接 IP")]),s._v(" "),e("li",[s._v("第三行,记录了一些我们比较有用的信息，如下解析\n"),e("ul",[e("li",[s._v("Query_time,这条 SQL 执行的时间,越长则越慢")]),s._v(" "),e("li",[s._v("Lock_time,在 MySQL 服务器阶段(不是在存储引擎阶段)等待表锁时间")]),s._v(" "),e("li",[s._v("Rows_sent,查询返回的行数")]),s._v(" "),e("li",[s._v("Rows_examined,查询检查的行数，越长就当然越费时间")])])]),s._v(" "),e("li",[s._v("第四行,设置时间戳，没有实际意义，只是和第一行对应执行时间。")]),s._v(" "),e("li",[s._v("第五行及后面所有行（第二个# Time:之前） ,执行的 sql 语句记录信息，因为 sql 可能会很长。")])]),s._v(" "),e("h3",{attrs:{id:"分析码查询日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分析码查询日志"}},[s._v("#")]),s._v(" 分析码查询日志")]),s._v(" "),e("h4",{attrs:{id:"mysql-自带的-mysqldumpslow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql-自带的-mysqldumpslow"}},[s._v("#")]),s._v(" MySQL 自带的 mysqldumpslow")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("[root@localhost mysql]# mysqldumpslow /var/lib/mysql/localhost-slow.log\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("常用参数说明：")]),s._v(" "),e("ul",[e("li",[s._v("-s 是表示按照何种方式排序\n"),e("ul",[e("li",[s._v("c 访问计数")]),s._v(" "),e("li",[s._v("l 锁定时间")]),s._v(" "),e("li",[s._v("r 返回记录")]),s._v(" "),e("li",[s._v("t 查询时间")]),s._v(" "),e("li",[s._v("al 平均锁定时间")]),s._v(" "),e("li",[s._v("ar 平均返回记录数")]),s._v(" "),e("li",[s._v("at 平均查询时间")])])]),s._v(" "),e("li",[s._v("-t 是 top n 的意思，即为返回前面多少条的数据")]),s._v(" "),e("li",[s._v("-g 后边可以写一个正则匹配模式，大小写不敏感的")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("示例：\n得到按照时间排序的前 10 条里面含有左连接的查询语句。\nmysqldumpslow -s t -t 10 -g “left join” /var/lib/mysql/localhost_slow.log\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("h4",{attrs:{id:"使用-mysqlsla-工具"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-mysqlsla-工具"}},[s._v("#")]),s._v(" 使用 mysqlsla 工具")]),s._v(" "),e("ul",[e("li",[s._v("mysqlsla 工具，功能非常强大。数据报表，非常有利于分析慢查询的原因，包括执行频率，数据量，查询消耗等。")]),s._v(" "),e("li",[s._v("不过此工具已停止维护，项目 github 介绍页面推荐使用 percona-toolkit，下面有介绍。\n"),e("ul",[e("li",[s._v("mysqlsla -lt /var/log/mysql/slow.log")])])])]),s._v(" "),e("h4",{attrs:{id:"使用-percona-toolkit-工具"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-percona-toolkit-工具"}},[s._v("#")]),s._v(" 使用 percona-toolkit 工具")]),s._v(" "),e("p",[s._v("percona-toolkit 是一组高级命令行工具的集合，可以查看当前服务的摘要信息，磁盘检测，分析慢\n查询日志，查找重复索引，实现表同步等等。")]),s._v(" "),e("ul",[e("li",[s._v("下载\nhttps://www.percona.com/downloads/percona-toolkit/3.0.11/binary/tarball/perconatoolkit-3.0.11_x86_64.tar.gz")]),s._v(" "),e("li",[s._v("安装")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("$ tar -xf percona-toolkit-3.0.11_x86_64.tar.gz\n$ cd percona-toolkit-3.0.11\n$ perl Makefile.PL\n$ make\n$ make install\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("ul",[e("li",[s._v("调错\n"),e("ul",[e("li",[s._v("Can't locate ExtUtils/MakeMaker.pm in @INC 错误的解决方式:"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("$ yum install -y perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])])]),s._v(" "),e("li",[s._v("Can't locate Time/HiRes.pm in @INC"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("$ yum install -y perl-Time-HiRes\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])])]),s._v(" "),e("li",[s._v("使用 pt-query-digest 查看慢查询日志")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  $ pt-query-digest /var/lib/mysql/localhost-slow.log\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])])])]),s._v(" "),e("h2",{attrs:{id:"数据类型优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据类型优化"}},[s._v("#")]),s._v(" 数据类型优化")]),s._v(" "),e("h3",{attrs:{id:"选择优化的数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#选择优化的数据类型"}},[s._v("#")]),s._v(" 选择优化的数据类型")]),s._v(" "),e("p",[s._v("基础优化原则：")]),s._v(" "),e("ul",[e("li",[s._v("更小的通常更好。尽量使用可以正确存储数据的最小数据类型。")]),s._v(" "),e("li",[s._v("简单就好。简单的数据类型需要更少额CPU周期。整型比字符串操作代价更低。用整型存储IP地址")]),s._v(" "),e("li",[s._v("尽量避免NULL")])]),s._v(" "),e("h4",{attrs:{id:"整数类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整数类型"}},[s._v("#")]),s._v(" 整数类型")]),s._v(" "),e("ul",[e("li",[s._v("几种整数类型\n"),e("ul",[e("li",[s._v("tinyint    8 位   -2^(7) ~ 2^(7)-1")]),s._v(" "),e("li",[s._v("smallint   16位   -2^(15) ~ 2^(15)-1")]),s._v(" "),e("li",[s._v("mediumint  24位   -2^(23) ~ 2^(23)-1")]),s._v(" "),e("li",[s._v("int        32位   -2^(31) ~ 2^(31)-1")]),s._v(" "),e("li",[s._v("bigint     64位   -2^(63) ~ 2^(63)-1\n"),e("br")])])]),s._v(" "),e("li",[s._v("整数类型可选unsigned属性，表示不允许负值，整数上限可大致提升一倍")]),s._v(" "),e("li",[s._v("整数类型可限制宽度，例如int(11),int(1),对于存储和计算这两个没有区别，区别在于可视化工具对这个\n参数的显示")])]),s._v(" "),e("h4",{attrs:{id:"实数类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实数类型"}},[s._v("#")]),s._v(" 实数类型")]),s._v(" "),e("ul",[e("li",[s._v("实数是带有小数部分的数字")]),s._v(" "),e("li",[s._v("decimal存储的整数可比bigint还大")]),s._v(" "),e("li",[s._v("decimal(18,9)小数点两边将各存储9个数字，一共9个字节。小数点前4个字节，小数点1个字节，小数点后4个字节")]),s._v(" "),e("li",[s._v("mysql5.0和更高的版本的decimal类型允许最多65个数字")]),s._v(" "),e("li",[s._v("decimal只是一种存储格式，在计算decimal会转为double类型")]),s._v(" "),e("li",[s._v("float占用4个字节，double占用8个字节")])]),s._v(" "),e("h4",{attrs:{id:"字符串类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串类型"}},[s._v("#")]),s._v(" 字符串类型")]),s._v(" "),e("ul",[e("li",[s._v("varchar 存储变长字符串，比定长类型更节省存储空间。\n"),e("ul",[e("li",[s._v("varchar 列长度最大长度小于或等于255，需要一个字节记录字符创长度。否则需要两个字节")]),s._v(" "),e("li",[s._v("varchar 在update时可能使行变得比原来更长，在InnoDB下需要分裂页使行可以放进去")]),s._v(" "),e("li",[s._v("innoDB可以把过长的varchar 存储为Blob")])])]),s._v(" "),e("li",[s._v("char 定长\n"),e("ul",[e("li",[s._v("适合长度都接近，不经常变更的数据。")]),s._v(" "),e("li",[s._v("例：char(1),y/n")])])]),s._v(" "),e("li",[s._v("不同点：\n"),e("ul",[e("li",[s._v("1.varchar在长度允许范围，保留字符变量的末尾空格。而char自动删除末尾空格")])])])]),s._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),e("p",[s._v("varchar\n事实证明更短的列有很大优势，消耗内存少。因为mysql通常会分配固定大小的内存块来保存内布置。\n尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用自盘临时表排序也同样糟糕。\n所以最好的策略是只分配真正需要的空间")])]),s._v(" "),e("ul",[e("li",[s._v("blob和text\n"),e("ul",[e("li",[s._v("都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储")]),s._v(" "),e("li")])])]),s._v(" "),e("h4",{attrs:{id:"日期和时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#日期和时间"}},[s._v("#")]),s._v(" 日期和时间")]),s._v(" "),e("ul",[e("li",[s._v("datetime\n"),e("ul",[e("li",[s._v("精度是秒")]),s._v(" "),e("li",[s._v("1001 - 9999年")]),s._v(" "),e("li",[s._v("8个字节")]),s._v(" "),e("li",[s._v("不依赖时区")])])]),s._v(" "),e("li",[s._v("timestamp\n"),e("ul",[e("li",[s._v("1970-01-01 00:00:00 开始 2038年")]),s._v(" "),e("li",[s._v("4个字节")]),s._v(" "),e("li",[s._v("秒数")]),s._v(" "),e("li",[s._v("依赖时区")])])])]),s._v(" "),e("h4",{attrs:{id:"位数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#位数据"}},[s._v("#")]),s._v(" 位数据")]),s._v(" "),e("ul",[e("li",[s._v("bit\n"),e("ul",[e("li",[s._v("最大支持64个位")]),s._v(" "),e("li",[s._v("mysql把bit当做字符串类型，而不是数字类型")]),s._v(" "),e("li")])])]),s._v(" "),e("p",[s._v("####选择标识符")]),s._v(" "),e("h4",{attrs:{id:"特殊类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特殊类型"}},[s._v("#")]),s._v(" 特殊类型")]),s._v(" "),e("p",[s._v("应该使用无符号整数存储IP地址。inet_aton() / inet_ntoa()")]),s._v(" "),e("h3",{attrs:{id:"mysql-schema设计中的陷阱"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql-schema设计中的陷阱"}},[s._v("#")]),s._v(" mysql schema设计中的陷阱")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("太多的列"),e("br"),s._v("\nmysql的存储引擎api在工作时需要在服务器层和引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将\n缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数结构的操作代价是非常高的。myISAM的变长\n结构和InnoDB的行结构则总是需要转换。转换的代价依赖于列的数量。")])]),s._v(" "),e("li",[e("p",[s._v("太多的关联"),e("br"),s._v("\nMysql限制了每个关联操作最多只能由61张表。一个粗略的经验法则，如果希望查询执行得快且并发性好，\n单个查询最好在12个表以内做关联")])]),s._v(" "),e("li",[e("p",[s._v("全能的枚举"),e("br"),s._v("\n注意防止过度使用枚举。反例： create table ...( country enum('','0','1','2'...'31') ).\n这种情况应该用整数作为外键关联到字典表或者查找表来查找具体值。枚举列表增加一个值，需要执行\n一次ALTER TABLE，5.0版本或者更高，这种操作是阻塞操作。")])]),s._v(" "),e("li",[e("p",[s._v("变相的枚举"),e("br"),s._v("\n如果只有真假两种情况用枚举是很合适的")])]),s._v(" "),e("li",[e("p",[s._v("非此发明的NULL"),e("br"),s._v("\n避免使用NULL，如果非要使用NULL也不用担心。mysql会在索引中存储null值")])])]),s._v(" "),e("h3",{attrs:{id:"范式和反范式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#范式和反范式"}},[s._v("#")]),s._v(" 范式和反范式")]),s._v(" "),e("ul",[e("li",[s._v("范式的优点和缺点\n"),e("ul",[e("li",[e("p",[s._v("范式化的更新操作通常比反范式要快")])]),s._v(" "),e("li",[e("p",[s._v("当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据")])]),s._v(" "),e("li",[e("p",[s._v("范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快")])]),s._v(" "),e("li",[e("p",[s._v("很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者group by")])]),s._v(" "),e("li",[e("p",[s._v("范式化的设计缺点就是需要更多的关联。更过的关联查询，代价昂贵，也可能使一些索引策略失效。")])])])])]),s._v(" "),e("h3",{attrs:{id:"反范式的优点和缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反范式的优点和缺点"}},[s._v("#")]),s._v(" 反范式的优点和缺点")]),s._v(" "),e("ul",[e("li",[s._v("避免高昂的关联查询"),e("br"),s._v("\n不关联，则对大部分查询最差的情况-即使表没有使用索引-是全表扫描。当数据比内存大时，这可能\n不关联要快得多，因为这样避免了随机I/O")])]),s._v(" "),e("h3",{attrs:{id:"混用范式和反范式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#混用范式和反范式"}},[s._v("#")]),s._v(" 混用范式和反范式")]),s._v(" "),e("p",[s._v("举例：订单明细表有产品ID,还有冗余的产品名称，单价等。减少一次关联产品表的查询。")]),s._v(" "),e("h3",{attrs:{id:"缓存表和汇总表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存表和汇总表"}},[s._v("#")]),s._v(" 缓存表和汇总表")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("缓存表"),e("br"),s._v("\n用术语“缓存表”来表示存储那些可以比较简单地从schema其他表获取(但每次获取的速度比较慢)数据表(例\n如逻辑上冗余的数据)。")])]),s._v(" "),e("li",[e("p",[s._v("汇总表"),e("br"),s._v("\n保存的是使用GROUP BY语句聚合数据的表(例如，数据不是逻辑上冗余)。")])])]),s._v(" "),e("h3",{attrs:{id:"加快alter-table操作的速度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#加快alter-table操作的速度"}},[s._v("#")]),s._v(" 加快ALTER TABLE操作的速度")]),s._v(" "),e("p",[s._v("一般而言大部分，alter table操作将导致Mysql服务中断。"),e("br")]),s._v(" "),e("ul",[e("li",[s._v("解决方案：\n"),e("ul",[e("li",[s._v("先在备库上执行alter table ,然后和提供服务的主库进行切换")]),s._v(" "),e("li",[s._v("“影子拷贝”，用要求的表结构创建一张和源表无关的新表，通过重命名和删表操作交换两张表")])])]),s._v(" "),e("li",[s._v("改变列的属性值：alter column")])]),s._v(" "),e("h2",{attrs:{id:"创建高性能的索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建高性能的索引"}},[s._v("#")]),s._v(" 创建高性能的索引")]),s._v(" "),e("h3",{attrs:{id:"索引基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引基础"}},[s._v("#")]),s._v(" 索引基础")]),s._v(" "),e("p",[s._v("在mysql中索引是在存储引擎层实现的，而非服务层。")]),s._v(" "),e("h4",{attrs:{id:"b-tree索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-tree索引"}},[s._v("#")]),s._v(" B-tree索引")]),s._v(" "),e("p",[e("img",{attrs:{src:"/images/interview/db-1.png",alt:""}})]),s._v(" "),e("ul",[e("li",[s._v("MyISAM b-tree")]),s._v(" "),e("li",[s._v("InnoDB b+tree")]),s._v(" "),e("li",[s._v("索引对多个值进行排序的依据是Create table语句中定义索引时列额顺序。")]),s._v(" "),e("li",[s._v("B-tree索引查询的类型 "),e("br"),s._v("\n假设某表含有一个索引[name(varchar),sex(int),birthday(date)]\n"),e("ul",[e("li",[s._v("全值匹配"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("EXPLAIN SELECT * FROM vip_member\nWHERE NAME = '江诚' AND sex = 1 AND birthday = '2005-05-13';\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])])]),s._v(" "),e("li",[s._v("匹配最左前缀"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("EXPLAIN SELECT * FROM vip_member\nWHERE NAME = '江诚';\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])])]),s._v(" "),e("li",[s._v("匹配列前缀"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("EXPLAIN SELECT * FROM vip_member\nWHERE NAME LIKE '江%'\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])])]),s._v(" "),e("li",[s._v("匹配范围值"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("EXPLAIN SELECT * FROM vip_member\nWHERE NAME LIKE '江%'\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])])]),s._v(" "),e("li",[s._v("精确匹配某一列并范围匹配另外一列"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("EXPLAIN SELECT * FROM vip_member\nWHERE NAME = '江诚' AND sex = 1 AND birthday BETWEEN '1999-01-01' AND '2020-01-01';\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])])]),s._v(" "),e("li",[s._v("只访问索引的查询(覆盖索引)"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("EXPLAIN SELECT NAME,sex,birthday FROM vip_member\nWHERE NAME = '江诚' AND sex = 1 AND birthday = '2005-05-13';\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])])])])]),s._v(" "),e("li",[s._v("索引树中节点是有序的。除了查找值，索引还能用于排序，order by 操作")]),s._v(" "),e("li",[s._v("B-tree 索引的限制\n"),e("ul",[e("li",[s._v("不是按照索引的最左列开始查找，则无法使用索引")]),s._v(" "),e("li",[s._v("不能跳过索引中的列")]),s._v(" "),e("li",[s._v("如果查询中某个列是范围查询，这个列右边的所有列都无法使用索引优化查找")])])])]),s._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),e("p",[s._v("5.6版本中：对顺序abc的索引，当where条件是精确匹配顺序不是abc时，经过优化器的排序，也可以使用索引来优化。")])]),s._v(" "),e("h4",{attrs:{id:"哈希索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哈希索引"}},[s._v("#")]),s._v(" 哈希索引")]),s._v(" "),e("p",[s._v("哈希索引基于哈希表实现，只有精确匹配所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引\n列计算一个哈希码，哈希码是一个较小的值，并且不同于键值的行计算出来的哈希码也不一样。哈希索引将\n所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。")]),s._v(" "),e("ul",[e("li",[s._v("mysql中只有Memory引擎显示支持哈希索引。")]),s._v(" "),e("li",[s._v("哈希表限制\n"),e("ul",[e("li",[s._v("哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行")]),s._v(" "),e("li",[s._v("哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序")]),s._v(" "),e("li",[s._v("哈希索引也不支持部分索引列匹配查找，因为使用索引列的全部列计算哈希值")]),s._v(" "),e("li",[s._v("哈希索引只支持等值比较查询，=，in(),<=>,不支持范围")]),s._v(" "),e("li",[s._v("访问哈希索引的数据非常快，除非有喝多哈希冲突。")]),s._v(" "),e("li",[s._v("哈希冲突过多，索引维护操作的代价会很高")])])]),s._v(" "),e("li",[s._v("InnoDB引擎有一个特殊的功能叫做“自适应哈希索引” ，内部行为，用户无法控制和配置，可以关闭。")]),s._v(" "),e("li",[s._v("创建自定义哈希索引")]),s._v(" "),e("li",[s._v("在b-tree索引列上创建一个字段为存储计算好的哈希值")]),s._v(" "),e("li",[s._v("CRC32()函数对字段进行哈希值计算")]),s._v(" "),e("li",[s._v("可以使用触发器，对新增数据的某目标列进行哈希计算，然后存放这行数据的索引列字段。")])]),s._v(" "),e("h4",{attrs:{id:"空间数据索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#空间数据索引"}},[s._v("#")]),s._v(" 空间数据索引")]),s._v(" "),e("ul",[e("li",[s._v("MyISAM支持空间索引")])]),s._v(" "),e("h4",{attrs:{id:"全文索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全文索引"}},[s._v("#")]),s._v(" 全文索引")]),s._v(" "),e("p",[s._v("全文索引时一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他\n几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词，词干和复数，布尔搜索等。全文索引更\n类似于搜索引擎做的事情，而不是简单的where条件匹配。")]),s._v(" "),e("h3",{attrs:{id:"索引的优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引的优点"}},[s._v("#")]),s._v(" 索引的优点")]),s._v(" "),e("ul",[e("li",[s._v("索引大大减少了服务器需要扫描的数据量")]),s._v(" "),e("li",[s._v("索引可以帮助服务器避免排序和临时表")]),s._v(" "),e("li",[s._v("索引可以将随机I/O变为顺序I/O")])]),s._v(" "),e("h3",{attrs:{id:"高性能的索引策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高性能的索引策略"}},[s._v("#")]),s._v(" 高性能的索引策略")]),s._v(" "),e("ul",[e("li",[s._v("独立的列 "),e("br"),s._v("\n如果查询中的列不是独立的，则Mysql就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也\n不能是函数的参数")])]),s._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[s._v("WARNING")]),s._v(" "),e("p",[s._v("反例 "),e("br"),s._v("\nselect * from order where price + 1 = 6 "),e("br"),s._v("\nselect * from order where to_days(current_date) - to_days(date_col) <= 10")])]),s._v(" "),e("ul",[e("li",[e("p",[s._v("前缀索引和索引选择性"),e("br"),s._v("\n需要索引的字符列很长时，会让索引变得大且慢。对于BLOB,TEXT或很长的VARCHAR，必须使用前缀索引。")]),s._v(" "),e("ul",[e("li",[s._v("可以使用哈希值代替字符列进行索引")]),s._v(" "),e("li",[s._v("尽量选择前缀的长度接近唯一索引的数据分布")]),s._v(" "),e("li",[s._v("ALTER TABLE ORDER ADD KEY(product_name(7)) , 7是前缀索引的对原字段截取的长度")]),s._v(" "),e("li",[s._v("缺点： mysql无法使用前缀索引做order by 和 group by ，也不能使用它做覆盖索引")])])]),s._v(" "),e("li",[e("p",[s._v("多列索引"),e("br"),s._v("\n在多个单列索引表中查询，往往只会触发其中一个索引，但事也有特例。我这里使用的5.6版本"),e("br"),s._v("\n在user表上设计三个单列索引name,sex,birthday")]),s._v(" "),e("ul",[e("li",[s._v("三列or连接，无索引匹配"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("EXPLAIN SELECT * FROM vipdb.user WHERE NAME = '丁雁勤' OR sex = 0 OR birthday = '1997-05-03';\nEXPLAIN SELECT * FROM vipdb.user WHERE NAME = '丁雁勤' OR birthday = '1997-05-03' OR sex = 0;\nEXPLAIN SELECT * FROM vipdb.user WHERE sex = 0 OR NAME = '丁雁勤' OR birthday = '1997-05-03';\nEXPLAIN SELECT * FROM vipdb.user WHERE sex = 0 OR birthday = '1997-05-03' OR NAME = '丁雁勤';\nEXPLAIN SELECT * FROM vipdb.user WHERE birthday = '1997-05-03' OR sex = 0 OR NAME = '丁雁勤';\nEXPLAIN SELECT * FROM vipdb.user WHERE birthday = '1997-05-03' OR NAME = '丁雁勤' OR sex = 0;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])])]),s._v(" "),e("li",[s._v("三列and连接，过滤比例最高的单列会匹配索引,下面这些匹配name索引"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("EXPLAIN SELECT * FROM vipdb.user WHERE NAME = '丁雁勤' AND sex = 0 AND birthday = '1997-05-03';\nEXPLAIN SELECT * FROM vipdb.user WHERE NAME = '丁雁勤' AND birthday = '1997-05-03' AND sex = 0;\nEXPLAIN SELECT * FROM vipdb.user WHERE sex = 0 AND NAME = '丁雁勤' AND birthday = '1997-05-03';\nEXPLAIN SELECT * FROM vipdb.user WHERE sex = 0 AND birthday = '1997-05-03' AND NAME = '丁雁勤';\nEXPLAIN SELECT * FROM vipdb.user WHERE birthday = '1997-05-03' AND sex = 0 AND NAME = '丁雁勤';\nEXPLAIN SELECT * FROM vipdb.user WHERE birthday = '1997-05-03' AND NAME = '丁雁勤' AND sex = 0;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])])]),s._v(" "),e("li",[s._v("两列or连接，触发索引合并"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("EXPLAIN SELECT * FROM vipdb.user WHERE sex = 0 OR birthday = '1997-05-03';\nEXPLAIN SELECT * FROM vipdb.user WHERE sex = 0 OR NAME = '丁雁勤';\nEXPLAIN SELECT * FROM vipdb.user WHERE birthday = '1997-05-03' OR sex = 0;\nEXPLAIN SELECT * FROM vipdb.user WHERE birthday = '1997-05-03' OR NAME = '丁雁勤';\nEXPLAIN SELECT * FROM vipdb.user WHERE NAME = '丁雁勤' OR birthday = '1997-05-03';\nEXPLAIN SELECT * FROM vipdb.user WHERE NAME = '丁雁勤' OR sex = 0;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])])]),s._v(" "),e("li",[s._v("两列and连接，只匹配过滤度最高的那个"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("EXPLAIN SELECT * FROM vipdb.user WHERE sex = 0 AND birthday = '1997-05-03';\nEXPLAIN SELECT * FROM vipdb.user WHERE sex = 0 AND NAME = '丁雁勤';\nEXPLAIN SELECT * FROM vipdb.user WHERE birthday = '1997-05-03' AND sex = 0;\nEXPLAIN SELECT * FROM vipdb.user WHERE birthday = '1997-05-03' AND NAME = '丁雁勤';\nEXPLAIN SELECT * FROM vipdb.user WHERE NAME = '丁雁勤' AND birthday = '1997-05-03';\nEXPLAIN SELECT * FROM vipdb.user WHERE NAME = '丁雁勤' AND sex = 0;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])])]),s._v(" "),e("li",[s._v("三列and 和 or 同时使用，会触发索引合并，多个and被匹配到过滤度最高，然后选择一个or连接列"),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// Using union(name,birthday); Using where\nEXPLAIN SELECT * FROM vipdb.user WHERE NAME = '丁雁勤' AND sex = 0 OR birthday = '1997-05-03';\n\n// Using union(name,sex); Using where\nEXPLAIN SELECT * FROM vipdb.user WHERE NAME = '丁雁勤' AND birthday = '1997-05-03' OR sex = 0;\n\n// Using union(name,birthday); Using where\nEXPLAIN SELECT * FROM vipdb.user WHERE sex = 0 AND NAME = '丁雁勤' OR birthday = '1997-05-03';\n\n// Using union(birthday,name); Using where\nEXPLAIN SELECT * FROM vipdb.user WHERE sex = 0 AND birthday = '1997-05-03' OR NAME = '丁雁勤';\n\n// Using union(birthday,name); Using where\nEXPLAIN SELECT * FROM vipdb.user WHERE birthday = '1997-05-03' AND sex = 0 OR NAME = '丁雁勤';\n\n// Using union(name,sex); Using where\nEXPLAIN SELECT * FROM vipdb.user WHERE birthday = '1997-05-03' AND NAME = '丁雁勤' OR sex = 0;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br")])])])]),s._v(" "),e("p",[s._v("索引合并策略有时候是一种优化的结果，但实际上更多的时候说明了表上的索引建得很糟糕")]),s._v(" "),e("ul",[e("li",[s._v("当出现服务器对多个索引做相交操作时(通常有多个AND条件)，通常意味着需要一个包含所有相关列索引，而不是多个独立的单列索引")]),s._v(" "),e("li",[s._v("当服务器需要对多个索引做联合操作时(通常有多个OR条件)，通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上。\n特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候")]),s._v(" "),e("li",[s._v("更重要的是，优化器不会把这些计算到“查询成本”(cost)中,优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致\n该执行计划还不如直接走全表扫描。这样做不但会消耗更多的CPU和内存资源，还可能会影响查询的并发性，但如果是单独运行这样\n的查询往往会忽略对并发性的影响。\n可以使用 optimizer_switch来关闭索引合并功能。")])])]),s._v(" "),e("li",[e("p",[s._v("选择合适的索引顺序 "),e("br"),s._v("\n一般来说根据经验法则，将选择性更高的列放到索引的前面会更好。sum(column) 查询出的值越小，选择性越高。")])]),s._v(" "),e("li",[e("p",[s._v("聚簇索引 "),e("br")]),s._v(" "),e("ul",[e("li",[s._v("聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。\n"),e("ul",[e("li",[s._v("聚簇索引：当找到索引匹配的值时，同时也就找到了数据行")]),s._v(" "),e("li",[s._v("非聚簇索引：当找到索引匹配的值时，只能得到该索引的值和对应的主键ID")])])]),s._v(" "),e("li",[s._v("当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。“聚簇”表示数据行和相邻的键值紧凑地存储在一起")]),s._v(" "),e("li",[s._v("因为无法同时吧数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引")]),s._v(" "),e("li",[s._v("覆盖索引可以模拟多个聚簇索引的情况\n"),e("ul",[e("li",[s._v("不完全体聚簇索引，当匹配到索引的值时，只能得到该索引上全部列的值，而非数据行")])])]),s._v(" "),e("li",[s._v("InnoDB的聚簇索引一般就是主键ID形成的主键聚集索引")]),s._v(" "),e("li",[s._v("InnoDB，如果没有显示指定主键列，会隐式定义一个主键作为聚簇索引。")]),s._v(" "),e("li",[s._v("聚簇索引数据的优点\n"),e("ul",[e("li",[s._v("可以把相关数据保存在一起。")]),s._v(" "),e("li",[s._v("数据访问更快")]),s._v(" "),e("li",[s._v("使用覆盖索引扫描的查询可以直接使用页节点中的主键值。")])])]),s._v(" "),e("li",[s._v("聚簇索引数据的缺点\n"),e("ul",[e("li",[s._v("聚簇数据最大限度的提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚集索引\n也就没什么优势了。")]),s._v(" "),e("li",[s._v("插入速度严重依赖插入顺序。按照主键的数据顺序插入是加载数据到InnoDB表中速度最快的方式，但如果不是按照主键顺序加载数据，那么在加载完成\n后最好使用OPTIMIZE TABLE命令重新组织一下表")]),s._v(" "),e("li",[s._v("更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置")]),s._v(" "),e("li",[s._v("基于聚簇索引的表插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已\n满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。")]),s._v(" "),e("li",[s._v("聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候")]),s._v(" "),e("li",[s._v("二级索引(非聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。")]),s._v(" "),e("li",[s._v("二级索引访问需要两次索引查找，而不是一次。")])])]),s._v(" "),e("li",[s._v("聚集索引的要求\n"),e("ul",[e("li",[s._v("连续主键的插入，避免频繁页分裂，避免碎片数据，避免数据稀疏")])])]),s._v(" "),e("li",[s._v("聚集索引，主键顺序插入导致对主键的频繁获取，称为了添加数据的瓶颈。将InnoDB升级到支持 innodb_autoinc_lock_mode")])])]),s._v(" "),e("li",[e("p",[s._v("覆盖索引"),e("br"),s._v("\n如果一个索引包含(或者说覆盖)所有需要查询的字段的值，我们就称之“覆盖索引”。")]),s._v(" "),e("ul",[e("li",[s._v("不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引，空间索引和全文索引都不存储索引列的值。")])])]),s._v(" "),e("li",[e("p",[s._v("使用索引扫描来做排序"),e("br")]),s._v(" "),e("ul",[e("li",[s._v("只有当索引的列顺序和order by 子句的顺序完全一致，并且所有列的排序方向(倒序或正序)都一样时，mysql才能使用索引来对结果做排序。\n如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一个表时，才能使用索引做排序。order by子句和查找型查询的限制是\n一样的：需要满足索引的最左前缀的要求；否则mysql都需要执行排序操作，而无法利用索引排序。")]),s._v(" "),e("li",[s._v("有一种情况下order by子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果where子句或者JOIN子句中对这些列指定了常量，\n就可以“弥补”索引的不足。如下例："),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("假设有索引(name,sex,birthday)\n1.正例：where子句前导列为常量\nselect * from user where name = 'david' order by sex,birthday\n2.正例：where子句常量前导列和order by子句第一列一起构成最左前缀\nselect * from user where name = 'david' order by sex\n3.正例：order by 子句name和sex一起构成了最左前缀\nselect * from user where name like 'd%' order by name,sex\n4.反例：order by子句中两列不符合排序方向一致性\nselect * from user where name = 'david' order by sex desc,birthday asc\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])])])])]),s._v(" "),e("li",[e("p",[s._v("压缩(前缀压缩)索引"),e("br"),s._v("\nMyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。")]),s._v(" "),e("ul",[e("li",[s._v('MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后讲其他值和第一个值惊醒比较得到相同前缀的字节数和剩余的不同后缀部分，\n把这部分存储起来即可。例如索引块中的第一个值是"perform",第二个值是"performance"，那么第二个值的前缀压缩后存储的是类似"7,ance"\n这样的形式。MyISAM对行指针也采用类似的前缀压缩。')])])]),s._v(" "),e("li",[e("p",[s._v("冗余和重复索引"),e("br"),s._v("\n重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。")]),s._v(" "),e("ul",[e("li",[s._v("应该尽量扩招已有的索引而不是创建新索引")]),s._v(" "),e("li",[s._v("索引列越多插入的速度就会越慢")])])]),s._v(" "),e("li",[e("p",[s._v("未使用的索引"),e("br")]),s._v(" "),e("ul",[e("li",[s._v("在percona server或者MariaDB中先打开userstates服务器变量(默认是关闭的)，然后让服务器运行一段内饰件，在通过查询INFORMATION_SCHEMA.INDEX_STATISTICS\n就能查到每个索引的使用率")]),s._v(" "),e("li",[s._v("使用Percona toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告。这个工具\n不仅可以找出那些索引时未使用的，还可以了解查询的执行计划。")])])]),s._v(" "),e("li",[e("p",[s._v("索引和锁"),e("br")]),s._v(" "),e("ul",[e("li",[s._v("索引可以让查询锁定更少的。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然InnoDb\n的航所效率很高，内存使用也很少，但是锁定行的时候仍然会代劳额外的开销；其次，锁定超过需要的行会增加锁争用并减少并发性。")]),s._v(" "),e("li",[s._v("InnoDb只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。\n如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，Mysql服务器才能应用where子句。这时已经无法避免锁定行了，InnoDB\n已经锁住了这些行，到适当时候才能释放。在Mysql5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但是在早期的MYsql版本中，\nInnoDB只有在事务提交后才能释放锁。")]),s._v(" "),e("li",[s._v("举例：")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("select * from user where id < 5 and id <> 1;\n1.首先id是索引列，在存储引擎层过滤出1,2,3,4一共四行数据，并没有锁\n2.过滤的这四行数据到了服务层，被锁住\n3.然后where 子句 id<>1再过滤掉id=1的行\n4.释放锁，返回2,3,4行的数据\n5.很明显id=1不是我们最终需要的数据，却被加锁了，这必然引起锁的争用。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])])])]),s._v(" "),e("h3",{attrs:{id:"索引案例学习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引案例学习"}},[s._v("#")]),s._v(" 索引案例学习")]),s._v(" "),e("p",[s._v("案例：在婚恋网站上搜索条件引发的索引顺序问题")]),s._v(" "),e("ul",[e("li",[s._v("巧妙使用IN() 绕过最左前缀原则")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("假设索引(sex,name,birthday),\n1.下面这个子句依然满足索引列的全匹配\nwhere sex in (0,1) and name = 'david' and birthday = '2020-1-1' \n2.第一列列使用in,第二列使用like左前缀，依然能完全匹配\nWHERE sex IN (0,1) AND NAME LIKE '江%' AND birthday = '2005-05-13';\n3.第一列列使用in,第二列使用like左前缀，第三列使用范围，还是可以完全匹配\nWHERE sex IN (0,1) AND NAME LIKE '江%' AND birthday > '2005-05-13';\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("ul",[e("li",[s._v("避免多个范围条件")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("假设索引(birthday,sex,name)\n1.当出现多个范围查询时，在出现第一个范围列停止，后续列不再使用索引。下面这个子只有birthday用上索引，最左前缀\nWHERE birthday > '2005-05-13' AND sex > 0 AND NAME LIKE '江%';\n2.下面这个子句，也是在第一个范围列停止。也是sex列，最终匹配了两列，也是符合最左前缀\nEXPLAIN SELECT * FROM vip_member WHERE birthday IN ('2005-05-13','2020-01-01') AND sex > 0 AND NAME LIKE '江%';\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),e("p",[s._v("对in() 和 > , <这些查询都是范围查询，type=range。从Explain的结果是无法区分这两者的"),e("br"),s._v("\n1.对于in()来说是多个等值条件查询，可以使用后面的其他索引列"),e("br"),s._v("\n2.而> ,<,between等明显的范围查询，是不能使用后续的索引列"),e("br")])]),s._v(" "),e("ul",[e("li",[s._v("优化排序"),e("br"),s._v("\n在一个千万级表上做索引排序分页。假设存在索引(sex,birthday)"),e("br")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("1.起初执行是很快的\nSELECT * FROM USER WHERE sex = 1 ORDER BY birthday LIMIT 0,10;\n2.随着分页越来越靠后，查询变得很慢\nSELECT * FROM USER WHERE sex = 1 ORDER BY birthday LIMIT 100000,10;\n3.使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行，\n这可以减少Mysql扫描那些需要丢弃的行数。\n下面这个查询显示了利用索引进行高效的排序和分页\nSELECT * FROM USER INNER JOIN (\n   SELECT id FROM USER u WHERE u.sex = 1\n   ORDER BY birthday LIMIT 100000,10\n) AS u USING(id);\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br")])]),e("h3",{attrs:{id:"维护索引和表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#维护索引和表"}},[s._v("#")]),s._v(" 维护索引和表")]),s._v(" "),e("ul",[e("li",[s._v("check table 通常能够找出大多数的表和索引的错误")]),s._v(" "),e("li",[s._v("可以使用 repair table 命令来修复损坏的表")]),s._v(" "),e("li",[s._v("使用show index from table 查看索引的基数")]),s._v(" "),e("li",[s._v("数据碎片\n"),e("ul",[e("li",[s._v("行碎片： 这种碎片指的是数据行被存储为多个地方的多个片段中。即使查询只从索引中访问一行记录，行碎片也会导致性能下降。")]),s._v(" "),e("li",[s._v("行间碎片： 行间碎片是指逻辑上顺序的页，或者行在磁盘上不是顺序存储的。行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大的影响，因为\n这些操作原本能够从磁盘上顺序存储的数据中获益。")]),s._v(" "),e("li",[s._v("剩余空间碎片：剩余空间碎片是指数据页中有大量的空余空间。这会导致服务器读取大量不需要的数据，从而造成浪费。"),e("br"),s._v("\n对于MyISAM表这三类碎片都可能发生，但InnoDB不会出现短小的行碎片，InnoDB会一定短小的行并重写到一个片段中。\n可以通过执行OPTIMIZE TABLE或者导出导入的方式来重新整理数据。")])])])]),s._v(" "),e("h2",{attrs:{id:"查询性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查询性能优化"}},[s._v("#")]),s._v(" 查询性能优化")]),s._v(" "),e("h3",{attrs:{id:"慢查询基础-优化数据访问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#慢查询基础-优化数据访问"}},[s._v("#")]),s._v(" 慢查询基础：优化数据访问")]),s._v(" "),e("p",[s._v("1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列"),e("br"),s._v("\n2.确认MYsql服务层是否在分析大量超过需要的数据行"),e("br")]),s._v(" "),e("ul",[e("li",[s._v("是否向数据库请求了不需要的数据\n"),e("ul",[e("li",[s._v("查询不需要的记录"),e("br"),s._v("\n1.避免从引擎层返回大量不需要的数据行到服务层去过滤，使用索引尽量在引擎层过滤大量不需要的数据"),e("br"),s._v("\n2.避免从服务层返回大量不需要的数据行到应用中去取部分数据，使用limit限制")]),s._v(" "),e("li",[s._v("多表关联时返回全部列"),e("br"),s._v("\n只取需要的列，避免大量列在内存中复制操作")]),s._v(" "),e("li",[s._v("总是取出全部列"),e("br"),s._v("\n只取需要的列")]),s._v(" "),e("li",[s._v("重复查询相同的数据"),e("br"),s._v("\n可以依托redis这样的缓存，对热点数据进行缓存，降低对数据库的访问。")])])]),s._v(" "),e("li",[s._v("mysql是否在扫描额外的记录\n"),e("ul",[e("li",[s._v("响应时间 = 服务时间 + 排队时间\n"),e("ul",[e("li",[s._v("服务时间：指数据库处理这个查询真正花了多长时间")]),s._v(" "),e("li",[s._v("排队时间是指服务器因为等待某些资源而没有真正执行查询的时间-等待I/O，等待行锁")])])]),s._v(" "),e("li",[s._v("扫描的行数和返回的行数\n"),e("ul",[e("li",[s._v("一般来说引擎层返回的行数，在服务层中还需要过滤或者分页，到达应用的行数并不一定等于在引擎层中的行数")])])]),s._v(" "),e("li",[s._v("扫描的行数和访问类型：三种应用where条件，从好到坏\n"),e("ul",[e("li",[s._v("在索引中使用where条件来过滤不匹配的记录。这是在存储引擎层完成的。")]),s._v(" "),e("li",[s._v("使用索引覆盖扫描来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在mysql服务层完成的，但无需在回表查询")]),s._v(" "),e("li",[s._v("从数据表中返回数据，然后过滤不满足条件的记录。这在mysql服务层完成，mysql需要先从数据表读出记录然后过滤。")])])])])])]),s._v(" "),e("h3",{attrs:{id:"重构查询的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重构查询的方式"}},[s._v("#")]),s._v(" 重构查询的方式")]),s._v(" "),e("ul",[e("li",[s._v("一个复杂查询还是多个简单查询\n"),e("ul",[e("li",[s._v("一个复杂查询性能符合要求时，可以继续使用")]),s._v(" "),e("li",[s._v("当一个复杂查询优化多次还是不符合要求，那就拆成多个简单查询")])])]),s._v(" "),e("li",[s._v("切分查询\n"),e("ul",[e("li",[s._v("将一个大查询切分成多个小的简单查询，然后再汇总结果")])])]),s._v(" "),e("li",[s._v("分解关联查询\n"),e("ul",[e("li",[s._v("很多高性能的应用都会对关联查询进行分解。一个表进行一次单表查询，然后结果在应用程序中进行关联。")]),s._v(" "),e("li",[s._v("让缓存的效率更高")]),s._v(" "),e("li",[s._v("将查询分解后，执行单个查询可以减少锁的竞争")]),s._v(" "),e("li",[s._v("在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展")]),s._v(" "),e("li",[s._v("查询本身效率也可能会有所提升。")]),s._v(" "),e("li",[s._v("可以减少冗余记录的查询")]),s._v(" "),e("li",[s._v("更进一步，这样做相当于在应用中实现了哈希关联")])])])]),s._v(" "),e("h3",{attrs:{id:"查询执行的基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查询执行的基础"}},[s._v("#")]),s._v(" 查询执行的基础")]),s._v(" "),e("p",[e("img",{attrs:{src:"/images/interview/db-2.png",alt:""}}),s._v("\n1.客户端发送一条查询给服务器"),e("br"),s._v("\n2.服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段"),e("br"),s._v("\n3.服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划"),e("br"),s._v("\n4.mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询"),e("br"),s._v("\n5.将结果返回给客户端"),e("br")]),s._v(" "),e("ul",[e("li",[s._v("查询状态\n"),e("ul",[e("li",[s._v("sleep")]),s._v(" "),e("li",[s._v("query")]),s._v(" "),e("li",[s._v("locked")]),s._v(" "),e("li",[s._v("analyzing and statistics")]),s._v(" "),e("li",[s._v("copying to tmp table [on disk]")]),s._v(" "),e("li",[s._v("sorting result")]),s._v(" "),e("li",[s._v("sending data")])])]),s._v(" "),e("li",[s._v("查询缓存")]),s._v(" "),e("li",[s._v("查询优化处理\n"),e("ul",[e("li",[s._v("语法解析器和预处理")]),s._v(" "),e("li",[s._v("查询优化器"),e("br"),s._v("\nmysql能够处理的优化类型：\n"),e("ul",[e("li",[s._v("重新定义关联表的顺序")]),s._v(" "),e("li",[s._v("将外连接转化成内连接")]),s._v(" "),e("li",[s._v("使用等价表换规则")]),s._v(" "),e("li",[s._v("优化Count(),min(),max()")]),s._v(" "),e("li",[s._v("预估并转化为常数表达式")]),s._v(" "),e("li",[s._v("覆盖索引扫描")]),s._v(" "),e("li",[s._v("子查询优化")]),s._v(" "),e("li",[s._v("提前终止查询")]),s._v(" "),e("li",[s._v("等值传播")]),s._v(" "),e("li",[s._v("列表in()的比较")])])]),s._v(" "),e("li",[s._v("数据和索引的统计信息")]),s._v(" "),e("li",[s._v("mysql如何执行关联查询")]),s._v(" "),e("li",[s._v("执行计划")]),s._v(" "),e("li",[s._v("关联查询优化器")]),s._v(" "),e("li",[s._v("排序优化")])])]),s._v(" "),e("li",[s._v("查询执行引擎")]),s._v(" "),e("li",[s._v("返回结果给客户端")])]),s._v(" "),e("h3",{attrs:{id:"mysql查询优化器的局限性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql查询优化器的局限性"}},[s._v("#")]),s._v(" mysql查询优化器的局限性")]),s._v(" "),e("ul",[e("li",[s._v("关联子查询\n"),e("ul",[e("li",[s._v("子查询的性能要看实际测试的结果")])])]),s._v(" "),e("li",[s._v("Union的限制")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("(SELECT id,NAME,sex,birthday FROM USER WHERE NAME LIKE '李%' ORDER BY id LIMIT 20)\nUNION ALL\n(SELECT id,NAME,sex,birthday FROM USER WHERE NAME LIKE '丁%' ORDER BY id LIMIT 20)\nORDER BY id\nLIMIT 20;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("ul",[e("li",[e("p",[s._v("索引合并优化")])]),s._v(" "),e("li",[e("p",[s._v("请参考前面")])]),s._v(" "),e("li",[e("p",[s._v("等值传递")])]),s._v(" "),e("li",[e("p",[s._v("并行执行")]),s._v(" "),e("ul",[e("li",[s._v("mysql无法利用多喝特性来并行执行查询")])])]),s._v(" "),e("li",[e("p",[s._v("哈希关联")]),s._v(" "),e("ul",[e("li",[s._v("mysql 并不支持哈希关联")])])]),s._v(" "),e("li",[e("p",[s._v("松散索引扫描")]),s._v(" "),e("ul",[e("li",[s._v("mysql并不支持松散索引扫描")])])]),s._v(" "),e("li",[e("p",[s._v("最大值和最小值")]),s._v(" "),e("ul",[e("li",[s._v("对于min()和max()，mysql的优化做的并不好")])])]),s._v(" "),e("li",[e("p",[s._v("在同一个表上查询和更新")]),s._v(" "),e("ul",[e("li",[s._v("在mysql中这是不允许的")])])])]),s._v(" "),e("h3",{attrs:{id:"查询优化器的提示-hint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查询优化器的提示-hint"}},[s._v("#")]),s._v(" 查询优化器的提示-hint")]),s._v(" "),e("ul",[e("li",[s._v("high_priority 和 low_priority"),e("br"),s._v("\n这个提示告诉mysql,当多个语句同时访问某一个表的时候，哪些语句的优先级相对高些，哪些语句的优先级相对低些\n"),e("ul",[e("li",[s._v("high_priority用于select语句时，mysql会将此select语句重新调度到所有正在等待表锁以便修改数据的语句之前。实际上是mysql是将其放在表\n的队列的最前面，而不是按照常规顺序等待。")]),s._v(" "),e("li",[s._v("low_priority 则正好相反，它会让该语句一致处于等待状态，只要队列中海油需要访问同一个表的语句。")])])]),s._v(" "),e("li",[s._v("delayed: 对insert和replace有效。会将使用该提示的语句立即返回给客户端，并将插入的行数据放入到缓存区，然后在表空闲时批量将数据写入。")]),s._v(" "),e("li",[s._v("straight_join 这个提示可以放置在select语句的select关键字之后，也可以放置在任何两个关联表的名字之间。第一个用法是让查询中所有的表\n按照在语句中出现的顺序进行关联。第二个用法则是固定其前后两个表的关联顺序。")]),s._v(" "),e("li",[s._v("sql_small_result 和 sql_big_result\n"),e("ul",[e("li",[s._v("sql_small_result 结果集很小，可以放到内存中的索引临时表做排序操作")]),s._v(" "),e("li",[s._v("sql_big_result 结果集可能会很大，建议使用磁盘临时表做排序操作")])])]),s._v(" "),e("li",[s._v("sql_buffer_result\n告诉优化器将查询结果放入到一个临时表，然后尽可能快的释放表锁")]),s._v(" "),e("li",[s._v("sql_cache 和 sql_no_cache\n"),e("ul",[e("li",[s._v("sql_cache 结果集缓存在查询缓存中")]),s._v(" "),e("li",[s._v("sql_no_cache 结果集不缓存")])])]),s._v(" "),e("li",[s._v("sql_calc_found_rows\n让mysql返回的结果集包含更多的信息")]),s._v(" "),e("li",[s._v("for update 和 lock in share mode\n"),e("ul",[e("li",[s._v("控制select语句的锁机制，只对实现了行级锁的存储引擎有效")])])])]),s._v(" "),e("h3",{attrs:{id:"优化特定类型的查询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化特定类型的查询"}},[s._v("#")]),s._v(" 优化特定类型的查询")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("优化count()查询"),e("br")]),s._v(" "),e("ul",[e("li",[s._v("count(*)")]),s._v(" "),e("li",[s._v("count需要扫描大量的行才能得到精确的结果，很难优化。可以增加汇总表，代替count().")])])]),s._v(" "),e("li",[e("p",[s._v("优化关联查询")]),s._v(" "),e("ul",[e("li",[s._v("确保on或者using子句中的列上有索引。 在创建索引的时候就要考虑到关联的顺序。当表A和表B用列C关联时，如果优化器的关联顺序是B,A，那么\n就不需要在B表的对应列上创建索引。只需要在关联顺序中的第二个表的响应列上创建索引")]),s._v(" "),e("li",[s._v("确保任何的GROUP BY和 ORDER BY找那个的表达式只涉及到一个表中的列，这样的mysql才有可能使用索引来优化这个过程")]),s._v(" "),e("li",[s._v("当升级mysql时需要注意：关联语法，运算符优先级等变化")])])]),s._v(" "),e("li",[e("p",[s._v("优化子查询：当5.6版本以上就不用关心用关联查询代替子查询了。")])]),s._v(" "),e("li",[e("p",[s._v("优化GROUP BY 和DISTINCT")]),s._v(" "),e("ul",[e("li",[s._v("使用标识列分组效率高")])])]),s._v(" "),e("li",[e("p",[s._v("优化limit分页")]),s._v(" "),e("ul",[e("li",[s._v("延迟关联提升效率大大的")])])]),s._v(" "),e("li",[e("p",[s._v("优化SQL_CALC_FOUND_ROWS")]),s._v(" "),e("ul",[e("li",[s._v("使用sql_calc_found_rows提示hint,可以获得去掉limit后满足条件的行数，可以作为分页的总数")])])]),s._v(" "),e("li",[e("p",[s._v("优化 union查询")])]),s._v(" "),e("li",[e("p",[s._v("静态查询分析")]),s._v(" "),e("ul",[e("li",[s._v("percona toolkit的pt-query-advisor能够解析查询日志，分析查询模式，然后给出潜在问题的查询")])])]),s._v(" "),e("li",[e("p",[s._v("使用用户自定义变量")])])]),s._v(" "),e("h2",{attrs:{id:"主从复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从复制"}},[s._v("#")]),s._v(" 主从复制")]),s._v(" "),e("h3",{attrs:{id:"主从复制原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从复制原理"}},[s._v("#")]),s._v(" 主从复制原理")]),s._v(" "),e("p",[e("img",{attrs:{src:"/images/interview/db-6.png",alt:""}})]),s._v(" "),e("h3",{attrs:{id:"主从复制实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从复制实践"}},[s._v("#")]),s._v(" 主从复制实践")]),s._v(" "),e("h4",{attrs:{id:"主服务器配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主服务器配置"}},[s._v("#")]),s._v(" 主服务器配置")]),s._v(" "),e("ul",[e("li",[s._v("第一步：修改 my.conf 文件：")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("在[mysqld]段下添加：\n#启用二进制日志\nlog-bin=mysql-bin\n#服务器唯一 ID，一般取 IP 最后一段\nserver-id=133\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("ul",[e("li",[s._v("第二步：重启 mysql 服务")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("service mysqld restart\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ul",[e("li",[s._v("第三步：建立帐户并授权 slave（登录到 MySQL）")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("mysql>GRANT FILE ON *.* TO 'root'@'%' IDENTIFIED BY '123456';\nmysql>GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* to 'root'@'%' identified by 'root';\nmysql>GRANT REPLICATION SLAVE ON *.* to 'root'@'%' identified by 'root';\n# 一般不用 root 帐号，“%”表示所有客户端都可能连，只要帐号，密码正确，此处可用具体客户端IP 代替，如 192.168.145.226，加强安全。\n\n# 刷新权限\nmysql> FLUSH PRIVILEGES;\n\n# 查看 mysql 现在有哪些用户\nmysql>select user,host from mysql.user;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br")])]),e("p",[s._v("第四步：查询 master 的状态")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("mysql> show master status;\n+------------------+----------+--------------+------------------+-------------------+\n| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |\n+------------------+----------+--------------+------------------+-------------------+\n| mysql-bin.000001 | 120 | db1 | mysql | |\n+------------------+----------+--------------+------------------+-------------------+\n1 row in set\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("h4",{attrs:{id:"从服务器配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从服务器配置"}},[s._v("#")]),s._v(" 从服务器配置")]),s._v(" "),e("ul",[e("li",[s._v("第一步：修改 my.conf 文件")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("[mysqld]\nserver-id=135\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("ul",[e("li",[s._v("第二步： 删除 UUID 文件")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("错误处理：\n如果出现此错误：\nFatal error: The slave I/O thread stops because master and slave have equal MySQL\nserver UUIDs; these UUIDs must be different for replication to work.\n因为是 mysql 是克隆的系统所以 mysql 的 uuid 是一样的，所以需要修改。\n解决方法：\n删除/var/lib/mysql/auto.cnf 文件，重新启动服务。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("ul",[e("li",[s._v("第三步： 重启并登录到 MySQL 进行配置从服务器")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("mysql>change master to \\\nmaster_host='192.168.10.133',master_port=3306,master_user='root',master_password='ro \\\not',master_log_file='mysql-bin.000001',master_log_pos=569\n\n\n注意语句中间不要断开， master_port 为 mysql 服务器端口号(无引号)， master_user 为执行同步\n操作的数据库账户，“120”无单引号(此处的 120 就是 show master status 中看到的 position 的\n值，这里的 mysql-bin.000001 就是 file 对应的值)。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("ul",[e("li",[s._v("第四步：启动从服务器复制功能")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("mysql>start slave;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ul",[e("li",[s._v("第五步：检查从服务器复制功能状态：")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("mysql> show slave status\n……………………(省略部分)\nSlave_IO_Running: Yes //此状态必须 YES\nSlave_SQL_Running: Yes //此状态必须 YES\n……………………(省略部分)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[s._v("WARNING")]),s._v(" "),e("p",[s._v("注： Slave_IO 及 Slave_SQL 进程必须正常运行，即 YES 状态，否则都是错误的状态\n(如：其中一个 NO 均属错误)。")])]),s._v(" "),e("p",[e("img",{attrs:{src:"/images/interview/db-7.png",alt:""}})]),s._v(" "),e("h2",{attrs:{id:"mycat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mycat"}},[s._v("#")]),s._v(" Mycat")]),s._v(" "),e("h3",{attrs:{id:"mycat介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mycat介绍"}},[s._v("#")]),s._v(" Mycat介绍")]),s._v(" "),e("h4",{attrs:{id:"什么是-mycat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-mycat"}},[s._v("#")]),s._v(" 什么是 MyCAT？")]),s._v(" "),e("ul",[e("li",[s._v("官方网站： http://www.mycat.org.cn/")]),s._v(" "),e("li",[s._v("简单的说， MyCAT 就是：\n"),e("ul",[e("li",[s._v("一个彻底开源的，面向企业应用开发的“大数据库集群”")]),s._v(" "),e("li",[s._v("支持事务、 ACID、可以替代 Mysql 的加强版数据库")]),s._v(" "),e("li",[s._v("一个可以视为“Mysql”集群的企业级数据库，用来替代昂贵的 Oracle 集群")]),s._v(" "),e("li",[s._v("一个融合内存缓存技术、 Nosql 技术、 HDFS 大数据的新型 SQL Server")]),s._v(" "),e("li",[s._v("结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品")]),s._v(" "),e("li",[s._v("一个新颖的数据库中间件产品")])])]),s._v(" "),e("li",[s._v("MyCAT 的目标是：低成本的将现有的单机数据库和应用平滑迁移到“云”端，解决数据存储和业务\n规模迅速增长情况下的数据瓶颈问题。")])]),s._v(" "),e("h4",{attrs:{id:"mycat-的关键特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mycat-的关键特性"}},[s._v("#")]),s._v(" MyCAT 的关键特性")]),s._v(" "),e("ul",[e("li",[s._v("支持 SQL 92 标准")]),s._v(" "),e("li",[s._v("支持 Mysql 集群，可以作为 Proxy 使用")]),s._v(" "),e("li",[s._v("支持 JDBC 连接 ORACLE、 DB2、 SQL Server，将其模拟为 MySQL Server 使用")]),s._v(" "),e("li",[s._v("支持 galera for mysql 集群， percona-cluster 或者 mariadb cluster，提供高可用性数据分片集群")]),s._v(" "),e("li",[s._v("自动故障切换，高可用性")]),s._v(" "),e("li",[s._v("支持读写分离，支持 Mysql 双主多从，以及一主多从的模式")]),s._v(" "),e("li",[s._v("支持全局表，数据自动分片到多个节点，用于高效表关联查询")]),s._v(" "),e("li",[s._v("支持独有的基于 E-R 关系的分片策略，实现了高效的表关联查询")]),s._v(" "),e("li",[s._v("多平台支持，部署和实施简单")])]),s._v(" "),e("h4",{attrs:{id:"核心概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心概念"}},[s._v("#")]),s._v(" 核心概念")]),s._v(" "),e("ul",[e("li",[s._v("Schema : 由它指定逻辑数据库")]),s._v(" "),e("li",[s._v("Table : 逻辑表")]),s._v(" "),e("li",[s._v("DataNode : 真正存储节点")]),s._v(" "),e("li",[s._v("DataHost : 真正的数据库主机\nMyCAT 使用 Mysql 的通讯协议模拟成了一个 Mysql 服务器，并建立了完整的 Schema\n（数据库）、 Table （数据表）、 User(用户)的逻辑模型，并将这套逻辑模型映射到后端的存储节点\nDataNode（MySQL Instance）上的真实物理库中，这样一来，所有能使用 Mysql 的客户端以及\n编程语言都能将 MyCAT 当成是 Mysql Server 来使用，不必开发新的客户端协议。")])]),s._v(" "),e("h3",{attrs:{id:"mycat优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mycat优缺点"}},[s._v("#")]),s._v(" Mycat优缺点")]),s._v(" "),e("h4",{attrs:{id:"mycat-存在的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mycat-存在的问题"}},[s._v("#")]),s._v(" Mycat 存在的问题")]),s._v(" "),e("ul",[e("li",[s._v("跨库 join 问题\n"),e("ul",[e("li",[s._v("通过业务分析， 将不同库的 join 查询拆分成多个 select")]),s._v(" "),e("li",[s._v("建立全局表（每个库都有一个相同的表）")]),s._v(" "),e("li",[s._v("冗余字段（不符合数据库三范式）")]),s._v(" "),e("li",[s._v("E-R 分片（将有关系的记录都存储到一个库中）")]),s._v(" "),e("li",[s._v("最多支持跨两张表跨库的 join")])])]),s._v(" "),e("li",[s._v("分布式事务（弱事务）\n"),e("ul",[e("li",[s._v("强一致性事务（同步）")]),s._v(" "),e("li",[s._v("最终一致性事务（异步思想）")])])]),s._v(" "),e("li",[s._v("分布式主键\n"),e("ul",[e("li",[s._v("redis incr 命令")]),s._v(" "),e("li",[s._v("数据库（生成主键）")]),s._v(" "),e("li",[s._v("UUID")]),s._v(" "),e("li",[s._v("snowflake 算法\n"),e("br")])])])]),s._v(" "),e("h4",{attrs:{id:"mycat-解决的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mycat-解决的问题"}},[s._v("#")]),s._v(" Mycat 解决的问题")]),s._v(" "),e("ul",[e("li",[s._v("海量数据存储")]),s._v(" "),e("li",[s._v("查询优化")])]),s._v(" "),e("h3",{attrs:{id:"分片策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分片策略"}},[s._v("#")]),s._v(" 分片策略")]),s._v(" "),e("p",[s._v("MyCAT 支持水平分片与垂直分片：")]),s._v(" "),e("ul",[e("li",[s._v("水平分片：一个表格的数据分割到多个节点上，按照行分隔。")]),s._v(" "),e("li",[s._v("垂直分片：一个数据库中多个表格 A，B，C，A存储到节点1上，B存储到节点2上，C存储到节点3上。\n"),e("img",{attrs:{src:"/images/interview/db-8.png",alt:""}}),s._v("\nMyCAT 通过定义表的分片规则来实现分片，每个表格可以捆绑一个分片规则，每个分片规则指定一\n个分片字段并绑定一个函数，来实现动态分片算法。")]),s._v(" "),e("li",[s._v("1、 Schema：逻辑库，与 MySQL 中的 Database（数据库）对应，一个逻辑库中定义了所包括的Table。")]),s._v(" "),e("li",[s._v("2、 Table：表，即物理数据库中存储的某一张表，与传统数据库不同，这里的表格需要声明其所存\n储的逻辑数据节点 DataNode。 在此可以指定表的分片规则。")]),s._v(" "),e("li",[s._v("3、 DataNode： MyCAT 的逻辑数据节点，是存放 table 的具体物理节点，也称之为分片节点，通\n过 DataSource 来关联到后端某个具体数据库上")]),s._v(" "),e("li",[s._v("4、 DataSource：定义某个物理库的访问地址，用于捆绑到 Datanode 上")])]),s._v(" "),e("h3",{attrs:{id:"mycat分片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mycat分片"}},[s._v("#")]),s._v(" Mycat分片")]),s._v(" "),e("h4",{attrs:{id:"配置schema-xml"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置schema-xml"}},[s._v("#")]),s._v(" 配置Schema.xml")]),s._v(" "),e("ul",[e("li",[s._v("Schema.xml 作为 MyCat 中重要的配置文件之一， 管理着 MyCat 的逻辑库、表、分片规则、\nDataNode 以及 DataSource。 弄懂这些配置，是正确使用 MyCat 的前提。这里就一层层对该文\n件进行解析。\n"),e("ul",[e("li",[s._v("schema 标签用于定义 MyCat 实例中的逻辑库")]),s._v(" "),e("li",[s._v("Table 标签定义了 MyCat 中的逻辑表")]),s._v(" "),e("li",[s._v("dataNode 标签定义了 MyCat 中的数据节点，也就是我们通常说所的数据分片。")]),s._v(" "),e("li",[s._v("dataHost 标签在 mycat 逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读\n写分离配置和心跳语")])])])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('<?xml version="1.0"?>\n<!DOCTYPE mycat:schema SYSTEM "schema.dtd">\n<mycat:schema xmlns:mycat="http://io.mycat/">\n\t<schema name="cat_db" checkSQLschema="false" sqlMaxLimit="100">\n\t\t<table name="cat_user" dataNode="node1,node2,node3" \n\t\t\trule="auto-sharding-rang-mod-order" />\n\t</schema>\n\n\t<dataNode name="node1" dataHost="host1" database="cat_db" />\t\n\t<dataNode name="node2" dataHost="host2" database="cat_db" />\n\t<dataNode name="node3" dataHost="host3" database="cat_db" />\n\n\t<dataHost name="host1" maxCon="1000" minCon="10" balance="0"\n\t\twriteType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100">\n\t\t<heartbeat>select user()</heartbeat>\n\t\t<writeHost host="hostM1" url="192.168.163.201:3306" user="root" password="admin321">\n\t\t</writeHost>\n\t</dataHost>\n        <dataHost name="host2" maxCon="1000" minCon="10" balance="0"\n                writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100">\n                <heartbeat>select user()</heartbeat>\n                <writeHost host="hostM1" url="192.168.163.202:3306" user="root" password="admin321">\n                </writeHost>\n        </dataHost>\n        <dataHost name="host3" maxCon="1000" minCon="10" balance="0"\n                writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100">\n                <heartbeat>select user()</heartbeat>\n                <writeHost host="hostM1" url="192.168.163.203:3306" user="root" password="admin321">\n                </writeHost>\n        </dataHost>\n\n</mycat:schema>\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br")])]),e("h4",{attrs:{id:"配置server-xml"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置server-xml"}},[s._v("#")]),s._v(" 配置server.xml")]),s._v(" "),e("p",[s._v("server.xml 几乎保存了所有 mycat 需要的系统配置信息。最常用的是在此配置用户名、密码及权限。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('<user name="root" defaultAccount="true">\n    <property name="password">123456</property>\n    <property name="schemas">cat_db</property>\n    <property name="defaultSchema">cat_db</property>\n    \x3c!--No MyCAT Database selected 错误前会尝试使用该schema作为schema，不设置则为null,报错 --\x3e\n    \n    \x3c!-- 表级 DML 权限设置 --\x3e\n    \x3c!-- \t\t\n    <privileges check="false">\n        <schema name="TESTDB" dml="0110" >\n            <table name="tb01" dml="0000"></table>\n            <table name="tb02" dml="1111"></table>\n        </schema>\n    </privileges>\t\t\n     --\x3e\n</user>\n\n<user name="david">\n    <property name="password">admin321</property>\n    <property name="schemas">cat_db</property>\n    <property name="readOnly">true</property>\n    <property name="defaultSchema">cat_db</property>\n</user>\n\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br")])]),e("h4",{attrs:{id:"配置-rule-xml"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置-rule-xml"}},[s._v("#")]),s._v(" 配置 rule.xml")]),s._v(" "),e("p",[s._v("rule.xml 里面就定义了我们对表进行拆分所涉及到的规则定义。我们可以灵活的对表使用不同的分\n片算法，或者对表使用相同的算法但具体的参数不同。这个文件里面主要有 tableRule 和 function\n这两个标签。在具体使用过程中可以按照需求添加 tableRule 和 function。\n此配置文件可以不用修改，使用默认即可。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('<tableRule name="auto-sharding-rang-mod-order">\n<rule>\n    <columns>id</columns>\n    <algorithm>rang-mod-tkt</algorithm>\n</rule>\n</tableRule>\n<tableRule name="auto-sharding-rang-mod-order-link">\n        <rule>\n                <columns>orderId</columns>\n                <algorithm>rang-mod-tkt</algorithm>\n        </rule>\n</tableRule>\n\n<function name="jump-consistent-hash" class="io.mycat.route.function.PartitionByJumpConsistentHash">\n    <property name="totalBuckets">3</property>\n</function>\n<function name="rang-mod-tkt" class="io.mycat.route.function.PartitionByMod">\n    <property name="count">3</property>\n</function>\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br")])]),e("h4",{attrs:{id:"测试"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#测试"}},[s._v("#")]),s._v(" 测试")]),s._v(" "),e("p",[s._v("用可视化工具连接mycat,就像连接mysql一样使用就好。我这里配置的根据数据库数量，主键取模分配到各个库里面去。\n测试insert,观察数据落入到了哪个库。")]),s._v(" "),e("h3",{attrs:{id:"mycat读写分离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mycat读写分离"}},[s._v("#")]),s._v(" Mycat读写分离")]),s._v(" "),e("p",[s._v("MyCat 的读写分离是建立在 MySQL 主从复制基础之上实现的。\n数据库读写分离对于大型系统或者访问量很高的互联网应用来说，是必不可少的一个重要功能。对\n于 MySQL 来说，标准的读写分离是主从模式，一个写节点 Master 后面跟着多个读节点，读节点的\n数量取决于系统的压力，通常是 1-3 个读节点的配置\n"),e("img",{attrs:{src:"/images/interview/db-9.png",alt:""}})]),s._v(" "),e("h4",{attrs:{id:"schema-xml-修改配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#schema-xml-修改配置"}},[s._v("#")]),s._v(" Schema.xml 修改配置")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('<dataNode name="dn1" dataHost="localhost1" database="db1" />\n<dataNode name="dn2" dataHost="localhost1" database="db2" />\n<dataNode name="dn3" dataHost="localhost1" database="db3" />\n\n<dataHost name="localhost1" maxCon="1000" minCon="10" balance="1"\nwriteType="0" dbType="mysql" dbDriver="native" switchType="2"\nslaveThreshold="100">\n    <heartbeat>show slave status</heartbeat>\n    <writeHost host="hostM" url="192.168.25.134:3306" user="root"password="root">\n        <readHost host="hostS" url="192.168.25.166:3306" user="root"\n        password="root" />\n    </writeHost>\n</dataHost>\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br")])]),e("ul",[e("li",[s._v('(1) 设置 balance="1"与 writeType="0"\n'),e("ul",[e("li",[s._v("Balance 参数设置：\n"),e("ul",[e("li",[e("ol",[e("li",[s._v("balance=“0” , 所有读操作都发送到当前可用的 writeHost 上。")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[s._v("balance=“1”，所有读操作都随机的发送到 readHost。")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[s._v("balance=“2”，所有读操作都随机的在 writeHost、 readhost 上分发")])])])])]),s._v(" "),e("li",[s._v("WriteType 参数设置：\n"),e("ul",[e("li",[e("ol",[e("li",[s._v("writeType=“0” , 所有写操作都发送到可用的 writeHost 上。")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[s._v("writeType=“1”，所有写操作都随机的发送到 readHost。")])])]),s._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[s._v("writeType=“2”，所有写操作都随机的在 writeHost、 readhost 分上发。")])])])])]),s._v(" "),e("li",[s._v("“readHost 是从属于 writeHost 的，即意味着它从那个 writeHost 获取同步数据，因此，当它\n所属的 writeHost 宕机了，则它也不会再参与到读写分离中来，即“不工作了”，这是因为此时，\n它的数据已经“不可靠”了。基于这个考虑，目前 mycat 1.3 和 1.4 版本中，若想支持 MySQL 一\n主一从的标准配置，并且在主节点宕机的情况下，从节点还能读取数据，则需要在 Mycat 里配置\n为两个 writeHost 并设置 banlance=1。”")])])]),s._v(" "),e("li",[s._v('(2) 设置 switchType="2" 与 slaveThreshold="100"\n'),e("ul",[e("li",[s._v("switchType 目前有三种选择：\n"),e("ul",[e("li",[s._v("-1：表示不自动切换")]),s._v(" "),e("li",[s._v("1：默认值，自动切换")]),s._v(" "),e("li",[s._v("2：基于 MySQL 主从同步的状态决定是否切换")])])]),s._v(" "),e("li",[s._v("“Mycat 心跳检查语句配置为 show slave status ， dataHost 上定义两个新属性：\n"),e("ul",[e("li",[s._v('switchType="2" 与 slaveThreshold="100"，此时意味着开启 MySQL 主从复制状态绑定的读写\n分离与切换机制。 Mycat 心跳机制通过检测 show slave status 中的')]),s._v(" "),e("li",[s._v('"Seconds_Behind_Master", "Slave_IO_Running", "Slave_SQL_Running" 三个字段来确定当前\n主从同步的状态以及 Seconds_Behind_Master 主从复制时延。')])])])])])])])}),[],!1,null,null,null);a.default=l.exports}}]);